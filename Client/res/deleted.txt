// deleted code

#include "sys/types.h"		// (to get milliseconds)
#include "sys/timeb.h"


	// LOCK LUA
	// lua_lock(L);		// is a NOP macro! to be implemented by user in luaconfig
	
	while (m_DebugState == DEBUG_WAIT_USER_INPUT)
	{	// NOTE: because the client app has been disabled it should not call wxTimers or process a Close() event
		
		if (s_AppInst != nil)
		{	// non-wx client application

			// from the wx docs:
			// This virtual function is where the execution of a program written in wxWidgets starts. The default
			// implementation just enters the main loop and starts handling the events until it terminates, either
			// because ExitMainLoop has been explicitly called or because the last frame has been deleted and
			// GetExitOnFrameDelete flag is true (this is the default).
			int	res = s_AppInst->OnRun();
			if (res != 0)		break;
			/*while (s_AppInst->Pending())
				s_AppInst->Dispatch();
			*/
		}
		else
		{	// wx client application
			::wxSafeYield(this, true/*only if needed*/);
			
			//::wxMilliSleep(50);
		}
	}
	
	// UNLOCK LUA	
	//lua_unlock(L);	// is a NOP macro! to be implemented by user in luaconfig

-------------------------------------------------------------------------------

	// reparenting doesn't work on Win32
	wxWindow	*parent = wxWindow::FindWindowByName(ClientWindowName);
	if (parent != nil)
	{	// set new parent
		Reparent(parent);
		
		// change style to hook onto parent
		long	style = GetWindowStyleFlag();
		
		SetWindowStyle(style | wxFRAME_FLOAT_ON_PARENT);
		
		Update();
		Refresh();
		Raise();
	}
	
//---- About Frame ------------------------------------------------------------

class AboutFrame: public wxFrame
{
public:
	// ctor
	AboutFrame(wxFrame *parent)
		: wxFrame(parent, -1, "About Lua DDT debugger", wxDefaultPosition, wxSize(300, 280))
	{
		
		wxPanel	*panel = new wxPanel(this);
		
		wxBitmap	bm(LOAD_CRAW(InhanceLogo150x72));
		wxASSERT(bm.IsOk());
		wxASSERT(bm.HasAlpha());
		
		// wxStaticBitmap doesn't support transparency so composite manually
		// create composite bitmap with same size & depth
		wxBitmap	composite(bm);
		
		// clear background with menu color
		wxBrush	bck_brush(wxSystemSettings::GetColour(wxSYS_COLOUR_MENU));
		
		wxMemoryDC	temp_dc;
		
		temp_dc.SelectObject(composite);
		temp_dc.SetBackground(bck_brush);
		temp_dc.Clear();
		// draw the transparent PNG over it
		temp_dc.DrawBitmap(bm, 0, 0, true/*transparent*/);

		wxStaticBitmap	*bm_ctrl = new wxStaticBitmap(panel, -1, composite);
		wxASSERT(bm_ctrl);
		
		wxButton	*ok_btn = new wxButton(panel, DBGF_ID_ABOUT_OK, "OK");	
		ok_btn->SetDefault();
		
		m_LuaVersionCtrl = new wxStaticText(panel, -1, _T("Lua version ?"));

		wxBoxSizer	*vsizer = new wxBoxSizer(wxVERTICAL);
		
		vsizer->Add(new wxStaticText(panel, -1, _T("Lua DDT Debugger")), 0, wxALL | wxALIGN_CENTER, 4);
		vsizer->Add(new wxStaticText(panel, -1, _T("DDT version ") + DDT_VERSION), 0, wxALL | wxALIGN_CENTER, 4);
		vsizer->Add(m_LuaVersionCtrl, 0, wxALL | wxALIGN_CENTER, 4);
		vsizer->Add(new wxHyperlinkCtrl(panel, -1, "Lua DDT homepage", "http://www.inhance.com/developer"), 0, wxALL | wxALIGN_CENTER, 4);
		vsizer->Add(new wxStaticText(panel, -1, "written by Peter Laufenberg"), 0, wxALL | wxALIGN_CENTER, 4);
		vsizer->Add(new wxStaticText(panel, -1, "Â© 2008 Inhance Digital Corporation"), 0, wxALL | wxALIGN_CENTER, 4);
		vsizer->Add(bm_ctrl, 0, wxALL | wxALIGN_CENTER, 4);
		vsizer->Add(ok_btn, 0, wxALL | wxALIGN_CENTER, 4);

		panel->SetSizer(vsizer);
	}
	// dtor
	~AboutFrame()
	{
		// nop
	}
	
	void	SetLuaVersion(const wxString &v)
	{
		m_LuaVersionCtrl->SetLabel(v);
	}
	
	void	OnClose(wxCloseEvent &event)
	{
		if (event.CanVeto())
		{	// called by user, just hide it
			Hide();
			
			// veto the closing
			event.Veto();
		}
		else
		{	// called by DTOR, let it get closed
			event.Skip();
		}
	}
	
	void	OnOk(wxCommandEvent &event)
	{
		Hide();
	}

private:
	
	wxStaticText	*m_LuaVersionCtrl;
	
	DECLARE_EVENT_TABLE()
};

BEGIN_EVENT_TABLE(AboutFrame, wxFrame)
	
	EVT_CLOSE(				AboutFrame::OnClose)
	EVT_BUTTON(	DBGF_ID_ABOUT_OK,	AboutFrame::OnOk)
	
END_EVENT_TABLE()

-------------------------------------------------------------------------------

	if (m_AboutFrame)
	{	lua_getglobal(L, "_VERSION");
		if (!lua_isnil(L, -1))
		{	const char	*v_str = luaL_checkstring(L, -1);
		
			m_AboutFrame->SetLuaVersion(v_str);
		}
		// not yet available, probably because Lua libs aren't initialized yet
		
		lua_pop(L, 1);
	}

//---- Service DDT GUI --------------------------------------------------------

void	DebugFrame::ServiceDDT(void)
{
	if (!m_ActiveFlag)		return;
	
	if (s_AppInst != nil)
	{	// non-wx client application

		// from the wx docs:
		// This virtual function is where the execution of a program written in wxWidgets starts. The default
		// implementation just enters the main loop and starts handling the events until it terminates, either
		// because ExitMainLoop has been explicitly called or because the last frame has been deleted and
		// GetExitOnFrameDelete flag is true (this is the default).
		/*int	res = s_AppInst->OnRun();
		if (res != 0)		return;
		*/
		/*
		wxEventLoop	loop;
		
		wxEventLoop::SetActive(loop);
		*/
		
		// doesn't do anything
		wxYield();
		
		// doesn't work in non-wx client applications
		while (s_AppInst->Pending())	s_AppInst->Dispatch();
	}
}

//---- Service DDT GUI --------------------------------------------------------

static
int	lg_ServiceDDT(lua_State *L)
{
	if (gDebugFrame == nil)		return 0;		// should be error?
	
	gDebugFrame->ServiceDDT();
	
	return 0;
}

-------------------------------------------------------------------------------

	// create link (child of the toolbar!)
	m_InhanceLink = new wxHyperlinkCtrl(m_StatusBar, -1, "Lua DDT homepage"/*label*/, "http://www.inhance.com/developer", wxDefaultPosition, wxDefaultSize,  wxNO_BORDER | wxHL_CONTEXTMENU | wxHL_ALIGN_LEFT);
	wxASSERT(m_InhanceLink);

	if (m_StatusBar != nil && m_InhanceLink!= nil)
	{	// get status bar rect & move link in it
		wxRect	rect;

		m_StatusBar->GetFieldRect(3, rect);
		
		wxSize link_size = m_InhanceLink->GetSize();

		m_InhanceLink->Move(rect.x + 4, rect.y + (rect.height - link_size.y) / 2);
	}
	// else not yet created
	
	wxHyperlinkCtrl			*m_InhanceLink;
	
//---- Auto Freeze / Unfreeze Client -------------------------------------

class AutoFreezeUnfreeze
{
public:
	// ctor
	AutoFreezeUnfreeze(DDTCommInterface *comm)
	{
		wxASSERT(comm);
		
		m_Comm = comm;
		
		m_Comm->DDTFreezeClient();
	}
	// dtor
	virtual ~AutoFreezeUnfreeze()
	{
		m_Comm->DDTUnfreezeClient();
	}
private:
	DDTCommInterface	*m_Comm;
};

//-----------------------------------------------------------------------------

static
wxBitmap	LOAD_TRANSPARENT(int sz)
{
	/*
	// TOTAL PAIN IN THE ASS!
	wxBitmap	bm(sz, sz, 32);
	
	bool	f = bm.HasAlpha();
	
	wxMemoryDC	dc(bm);
	
	// wxBrush	brush(
	// dc.SetBackground(*wxTRANSPARENT_BRUSH);
	dc.SetBrush(wxBrush(wxColour(0, 0, 0, 0), wxSOLID));
	dc.SetPen(*wxTRANSPARENT_PEN);
	dc.DrawRectangle(0, 0, sz, sz);
	dc.SelectObject(wxNullBitmap);
	
	f = bm.HasAlpha();
	*/
	wxBitmap	bm("./res/empty.png");
	wxASSERT(bm.IsOk());
	
	return bm;
}

// get associated ptr
	wxUIntPtr	uiptr = GetItemData(itemIndex);
	if (uiptr == nil)			return;		// has no associated data (likely a watch "add")
		

	// get associated ptr
	wxUIntPtr	uiptr = m_ListCtrl->GetItemData(row);
	
	void	*hash_ptr = (void*)uiptr;
	
	int	tab_state = m_TableStateTab[hash_ptr];
	if (tab_state == TVS_UNINITIALIZED)	return;		// not a table

//-----------------------------------------------------------------------------

	// make sure has an image (isn't a self-reference)
	wxListItem	li;

	li.SetId(row);
	li.SetColumn(COL_KEY);
	li.SetMask(wxLIST_MASK_IMAGE);

	bool	ok = m_ListCtrl->GetItem(li/*&*/);
	wxASSERT(ok);

	const int	img_id = li.GetImage();
	if ((img_id == -1) || (img_id == DBGF_ID_BITMAP_EMPTY_PLACEHOLDER))		return;		// has no icon (self-reference)

	li.SetColumn(COL_VAL_PATH);
	li.SetMask(wxLIST_MASK_TEXT);

	ok = m_ListCtrl->GetItem(li/*&*/);

	const wxString	var_path = li.GetText();

	const bool	expand_f = (img_id == DBGF_ID_BITMAP_PLUS);

	wxLogMessage("clicked on row %d, path \"%s\", %s", row, var_path, expand_f ? "expand" : "collapse");

//-----------------------------------------------------------------------------

	for (int k = 1; true/*k <= n_upvalues*/ ; k++)
	{
		// C upvalues have always empty "" name
		const char	*name = lua_getupvalue(L, fn_abs_ind, k);
		if (name == nil)	break;
		
		const char	*type_str = lua_typename(L, lua_type(L, -1));
		
		// try to convert to string, gets nil if not (don't care about change, will be popped anyway)
		const char	*val_str = lua_tostring(L, -1);
		
		if (val_str != nil)
			up_values.Append(wxString::Format("%d: %s; ", k, val_str));
		else	up_values.Append(wxString::Format("%d: <%s>; ", k, type_str));
		
		// remove value
		lua_pop(L, 1);
	}
	
	if (!up_values.empty())		up_values.Trim();

//-----------------------------------------------------------------------------

	for (int k = 1; true/*k <= n_upvalues*/; k++)
	{
		const char	*name = lua_getupvalue(L, fn_abs_ind, k);
		if (name == nil)	break;
		
		// try to convert to string, returns nil if can't (don't care about change, will be popped anyway)
		const char	*val_str = lua_tostring(L, -1);
		
		if (val_str != nil)
			up_values.Append(wxString::Format("%d: %s = %s; ", k, name, val_str));
		else	up_values.Append(wxString::Format("%d: %s = <%s>; ", k, name, lua_typename(L, lua_type(L, -1))));
		
		// remove value
		lua_pop(L, 1);
	}
	
	if (!up_values.empty())		up_values.Trim();

//-----------------------------------------------------------------------------

	const void	*hash_key = ptr;
	const void	*iterated_hash_key = nil;
	
	if (indent == 0)
	{	// clear visited flags
		s_TableBranchVisitedHash.clear();
		
		// store root ptr
		m_RootTablePtr = iterated_hash_key = hash_key;
		
		// flag table itself as visited (don't take account of hierarchy)
		s_TableBranchVisitedHash[hash_key] = true;
	}
	else
	{	// test if has been visited (will default to false if has no entry)
		self_ref_f = s_TableBranchVisitedHash[hash_key];
		
		// flag as visited
		s_TableBranchVisitedHash[hash_key] = true;
		
	// ITERATE hash_key so state is unique
		
		// ADD with root ptr so is unique branch (XOR gives too narrow results)
		m_RootTablePtr = iterated_hash_key = (const void *)((unsigned long)m_RootTablePtr + (unsigned long)hash_key);
	}
	
	// always associate with ptr (because clears list in-between)
	m_ListCtrl->SetItemPtrData(m_Cnt, wxUIntPtr(iterated_hash_key));
	
	// get state
	int	tab_state = m_TableStateTab[iterated_hash_key];
	
	if (tab_state == TVS_UNINITIALIZED)
	{	// 1st read, set as visited & collapsed
		m_TableStateTab[iterated_hash_key] = tab_state = TVS_COLLAPSED;
	}
	
	if (self_ref_f)
	{	// PREVENT SELF-REFERENCE FROM RECURSING
		icon_id = -1;
		recurse_f = false;
	}

//-----------------------------------------------------------------------------

	// changed variable highlight
	if (indent <= m_LastIndent)
	{	// pop back 1 or more
		std::vector<wxString>::iterator	start_it = m_VarPathStack.begin();
		
		m_VarPathStack.erase(start_it + indent, start_it + m_LastIndent + 1);
	}
	else	wxASSERT((indent - m_LastIndent) == 1);		// can only grow by 1 unit
	
	m_LastIndent = indent;
	
	// concatenate stack
	if (m_VarPathStack.size() == 0)
		m_VarPathStack.push_back(key_name);
	else	m_VarPathStack.push_back(m_VarPathStack.back() + ":" + key_name);
	
	const wxString	var_path = m_VarPathStack.back();
	
	const wxString	prev_val_str = m_ChangedVarHash[var_path];
	
	if (!prev_val_str.IsSameAs(val_str))
	{	// variable changed!
	
		// remember
		m_ChangedVarHash[var_path] = val_str;
		
		if (prev_val_str.IsEmpty())
		{	// new var, do nothing?
		
		}
		else
		{	// existing var changed, highlight in RED
			clr = *wxRED;
		}
	}
	
	if (self_ref_f)
	{	// self reference in blue
		clr = *wxBLUE;
		// val_str = val_str + " (self reference)";
	}
	
//---- On Checkbox ------------------------------------------------------------

void	VarViewCtrl::OnRefreshVarView(wxCommandEvent &e)
{
	DoRefresh();
}

void	VarViewCtrl::DoRefresh(void)
{
	// this shouldn't be here?
	wxMenuEvent	me(wxEVT_COMMAND_MENU_SELECTED, DBGF_ID_UPDATE_VAR_FLAGS);
	
	AddPendingEvent(me);
	
	// e.Skip();		// let wx handle the rest?
}

//-----------------------------------------------------------------------------

	EVT_CHECKBOX(	DBGF_ID_CHECK_NUMBERS,			VarViewCtrl::OnRefreshVarView)  
	EVT_CHECKBOX(	DBGF_ID_CHECK_BOOLEANS,			VarViewCtrl::OnRefreshVarView)  
	EVT_CHECKBOX(	DBGF_ID_CHECK_STRINGS,			VarViewCtrl::OnRefreshVarView)  
	EVT_CHECKBOX(	DBGF_ID_CHECK_LUA_FUNCTIONS,		VarViewCtrl::OnRefreshVarView)  
	EVT_CHECKBOX(	DBGF_ID_CHECK_C_FUNCTIONS,		VarViewCtrl::OnRefreshVarView)  
	EVT_CHECKBOX(	DBGF_ID_CHECK_TABLES,			VarViewCtrl::OnRefreshVarView)
	EVT_CHECKBOX(	DBGF_ID_CHECK_TEMPORARIES,		VarViewCtrl::OnRefreshVarView)
	EVT_CHECKBOX(	DBGF_ID_CHECK_BUILTINS,			VarViewCtrl::OnRefreshVarView)
	
//-----------------------------------------------------------------------------

	std::vector<int>	m_ItemIndexToRootIndexTab;		// redundant?
		
	// make sure is not under a table
	const int	rootInd = m_ItemIndexToRootIndexTab[row];
	if (rootInd < 0)				return;		// don't let sub-table vars get edited

	
	wxASSERT(row < m_ItemIndexToRootIndexTab.size());
	const int	rootInd = m_ItemIndexToRootIndexTab[row];
		
	if (indent == 0)
	{	m_ItemIndexToRootIndexTab.push_back(m_RootCnt);		// redundant ?
	}
	else
	{	// (if under a table, store negative)
		m_ItemIndexToRootIndexTab.push_back(-m_RootCnt);
	}
	
	wxASSERT(row < m_ItemIndexToRootIndexTab.size());
	int	rootInd = m_ItemIndexToRootIndexTab[row];
	if (rootInd < 0)	return;				// don't remove sub-tables

//---- Set Next Variable ------------------------------------------------------
				
bool	VarViewCtrl::SetNextVariable(lua_State *L, lua_Debug *ar, wxString key_name, const wxString parent_var, const int indent, int level)
{
	Collected	ce;
	
	if (indent == 0)	m_RootCnt++;		// pre-indent
	
	ce.m_Index = m_CollectedList.size();
	ce.m_RootIndex = m_RootCnt;
	ce.m_Indent = indent;
	
	// check if is temporary variable (should be a local var)
	if (key_name.IsSameAs("(*temporary)"))
	{	// check whether should show
		if (!m_VarViewFlags->m_Temporaries)	return false;		// don't show
		else	key_name = "temporary";					// rename to more user-friendly
	}
	
	const int	val_type = lua_type(L, -1);
	
	wxString	val_str, val_type_str;
	
	val_type_str = lua_typename(L, val_type);
	
	bool	is_table = false, convert_to_ptr = false;
	
	switch (val_type)
	{	case LUA_TNIL:
			
			// always show since it's not a "type" proper
			val_str = "nil";
			ce.m_Type = CTYPE_NIL;
			break;
		
		case LUA_TBOOLEAN:
			
			if (!m_VarViewFlags->m_Booleans)	return false;
			
			val_str = (lua_toboolean(L, -1) != 0) ? "true" : "false";
			ce.m_Type = CTYPE_BOOLEAN;
			break;
			
		case LUA_TNUMBER:
			
			if (!m_VarViewFlags->m_Numbers)		return false;
			
			val_str = wxString::Format("%f", lua_tonumber(L, -1));
			ce.m_Type = CTYPE_NUMBER;
			break;
		
		case LUA_TSTRING:
			
			if (!m_VarViewFlags->m_Strings)		return false;
			
			val_str = lua_tostring(L, -1);
			ce.m_Type = CTYPE_STRING;
			break;
		
		case LUA_TFUNCTION:
		{	
			// is a function, determine if is C or Lua
			if ((!m_VarViewFlags->m_CFunctions) && (!m_VarViewFlags->m_LuaFunctions))	return false;
			
			// duplicate the function value on the stack, as will get popped by getinfo()
			// (otherwise will fuck up the next iteration)
			lua_pushvalue(L, -1);
			
			bool	ok = lua_getinfo(L, ">Snu", ar);
			wxASSERT(ok);
			
			if (m_VarViewFlags->m_CFunctions && (strcmp(ar->what, "C") == 0))
			{	ce.m_Type = CTYPE_C_FUNCTION;
				val_type_str = "C function";
				convert_to_ptr = true;
				
			}
			else if (m_VarViewFlags->m_LuaFunctions && (strcmp(ar->what, "Lua") == 0))
			{	ce.m_Type = CTYPE_LUA_FUNCTION;
				val_type_str = "Lua function";
				val_str = wxString::Format("line %d", ar->linedefined);
				// could embed source file for hyperlink?
			}
			
			// if didn't determine if was C or Lua function, skip
			if (val_type_str.IsSameAs("function"))			return false;
			
			// add parentheses if function name
			if (key_name[0] != '[')		key_name = key_name + "()";
		}	break;
		
		case LUA_TTABLE:
			
			if (!m_VarViewFlags->m_Tables)				return false;
			if ((indent == 0) && key_name.IsSameAs("_G"))		return false;		// ignore _G since Lua doesn't use it
			
			is_table = true;
			
			ce.m_Type = CTYPE_TABLE;
			convert_to_ptr = true;
			break;
			
		case LUA_TTHREAD:
			
			ce.m_Type = CTYPE_THREAD;
			val_type_str = "thread";
			convert_to_ptr = true;
			break;
			
		default:
			
			// usertype and others
			convert_to_ptr = true;
			ce.m_Type = CTYPE_USERDATA;
			break;
	}
	
	if (convert_to_ptr)
	{	// duplicate value to convert since will turn to integer
		lua_pushvalue(L, -1);
		// turn table value into ptr
		const void	*ptr = lua_topointer(L, -1);
		// pop to restore stack
		lua_pop(L, 1);
		// convert to string
		val_str = wxString::Format("%p", ptr);
	}
	
	wxASSERT(!val_str.IsEmpty());
	
	ce.m_KeyS = key_name;
	
	wxString	var_path;
	
	// variable PATH - not yet universal locator
	if (!parent_var.IsEmpty())
	{	if (key_name[0] == '[')
			var_path = parent_var + key_name;
		else	var_path = parent_var + "." + key_name;
	}
	else	var_path = key_name;
	
	ce.m_Path = var_path;
	
	bool	recurse_f = false;
	
	if (is_table)
	{	ce.m_ExpandedFlag = (m_ExpandedTablesHashSet.find(var_path) != m_ExpandedTablesHashSet.end());
		
		recurse_f = ce.m_ExpandedFlag;
		
		if (indent > MAX_TABLE_RECUSION)
		{
			val_str = "Maximum Table Recursion Level reached!";
			
			recurse_f = false;
		}
	}
	
	ce.m_ValS = val_str;
	ce.m_ValTypeS = val_type_str;
	ce.m_Level = level;
	
	m_CollectedList.push_back(ce);
	
	m_Cnt++;
	
	return recurse_f;
}

//---- Compare Line (used by sort()) -----------------------------------------

static
bool	comp_ln_fn(const int &elm1, const int &elm2)
{
	return (elm1 < elm2);
}

	EVT_BUTTON(			DBGF_ID_COMMAND_OK_BUTTON/*wxID_OK*/,	DebugFrame::OnOKButton)
	EVT_TEXT_ENTER(			DBGF_ID_COMMAND_TEXT_CONTROL,		DebugFrame::OnOKButton)

//---- On OK Button -----------------------------------------------------------

void	DebugFrame::OnOKButton(wxCommandEvent &e)
{
	if (L == nil)
	{
		// Log("ERROR - console's Lua state not defined");
		return;
	}		

	
	wxString	cmd = m_CommandTextCtrl->GetValue();
	
	if (cmd.IsEmpty())
	{	// no command, but send CR
		m_OutputTextCtrl->AppendText("\n");
		return;
	}
	
	m_OutputTextCtrl->SetColor(USER_WRITE);
	
	m_OutputTextCtrl->AppendText(cmd);
	m_OutputTextCtrl->AppendText("\n");
	
	m_OutputTextCtrl->SetColor(CONSOLE_WRITE);
	
	m_CommandTextCtrl->Clear();
	
	int	err = luaL_dostring(L, cmd.c_str());
	if (err != 0)
	{	// CACA - SHOULD WRITE TO LOG TOO!
		m_OutputTextCtrl->AppendText("lua error\n");
	}
	
	m_OutputTextCtrl->SetColor(NORMAL);
}

//---- Unclip -----------------------------------------------------------------

void	DebugFrame::Unclip(void)
{
	// make sure isn't outside of current desktop resolution
	wxRect	clip_rc, rc;
	
	// clip rect is whole virtual desktop
	clip_rc = ::wxGetClientDisplayRect();
	
	rc = wxWindow::GetRect();
	
	SetSize(rc);
	
	Refresh();
	Update();
}

//-----------------------------------------------------------------------------

class MyEventFilter: public wxEventFilter
{
public:
	// ctor
	MyEventFilter();
	// dtor
	virtual ~MyEventFilter();
	
	// implementation
	virtual int	FilterEvent(wxEvent &e);
	
	bool		m_EnabledFlag;
	
private:

	bool		m_RecurseLock;
};

MyEventFilter	m_MyEventFilter;

//-----------------------------------------------------------------------------

	MyEventFilter::MyEventFilter()
{
	m_EnabledFlag = false;
	m_RecurseLock = false;
		
}
	MyEventFilter::~MyEventFilter()
{
	m_EnabledFlag = false;	
}

int	MyEventFilter::FilterEvent(wxEvent &e)
{
	if (!m_EnabledFlag)	return Event_Skip;
	if (m_RecurseLock)	return Event_Ignore;
	
	AutoLock	recurse_guard(m_RecurseLock);
	
	const wxEventType	t = e.GetEventType();
	const wxEventCategory	cat = e.GetEventCategory();
	
	if ((t == wxEVT_NC_PAINT) || (t == wxEVT_PAINT) || (t == wxEVT_ERASE_BACKGROUND) || (t == wxEVT_UPDATE_UI) || (t == wxEVT_IDLE))	return Event_Skip;
	
	const wxClassInfo	*info = e.GetClassInfo();
	wxASSERT(info);
	
	// get event type name
	const wxString		typ_str = info->GetClassName();
	wxASSERT(!typ_str.IsEmpty());
	
	wxLogMessage("evt \"%s\"", typ_str);
	
	return Event_Skip;
}

//-----------------------------------------------------------------------------

template<typename Tr=char_traits<C>>
class OutStream: public std::basic_ostream<uint8_t, Tr>
{
public:
	using int_type = typename Tr::int_type;
	using pos_type = typename Tr::pos_type;
	using off_type = typename Tr::off_type;
	using traits_type = Tr;
};

using OutStream = std::basic_ostream<uint8_t>;
using OutStream = std::basic_ostream<char>;

template<typename C, typename Tr = char_traits<C>>
class DataOutputStream: public std::basic_ostream<C, Tr>

//---- Break ASAP -------------------------------------------------------------

void	DebugFrame::BreakNext(void)
{
	// NOTE: should NOT be contingent on m_BreakpointsFlag, so they can be set later
	if (m_L)
	{	// if Lua state is set, setup breakpoint right away
		SetLuaHook(m_L, BREAK_TYPE_INSTRUCTION);
		m_BreakASAPFlag = false;
	}
	else
	{	// otherwise wait til next opportunity
		m_BreakASAPFlag = true;				// unused ?
	}
}

//-----------------------------------------------------------------------------

	// typeid
	string	resum_arg_name = typeid(ds).name();
	
//-----------------------------------------------------------------------------

	&& (m_DebugState != DEBUG_STATE::WAIT_USER_INPUT))
	
	enum class DEBUG_STATE : int
{
	ILLEGAL = 0,
	WAIT_USER_INPUT,
	ABORT,
	RUN,
	STEP_INTO,
	STEP_OVER,
	STEP_OUT
};

//-----------------------------------------------------------------------------
	
	// should be MESSAGES
	switch (m_CurrentBottomNotebookPage)
	{	case NOTEBOOK_PAGE_LOCAL_VARIABLES:
	
			m_Collectors.OnDumpLuaLocals(m_L, m_LocalsVarViewCtrl);
			break;
		
		case NOTEBOOK_PAGE_GLOBAL_VARIABLES:
	
			m_Collectors.OnDumpLuaGlobals(m_L, m_GlobalsVarViewCtrl);
			break;
		
		case NOTEBOOK_PAGE_WATCH_VARIABLES:
			
			m_Collectors.OnDumpWatches(m_L, m_WatchList, m_WatchVarViewCtrl);
			break;
	}

//-----------------------------------------------------------------------------

	// C globals removed in Lua 5.2
	lua_pushstring(L, var_name);
	lua_rawget(L, LUA_ENVIRONINDEX);
	if (!lua_isnil(L, -1)) 
	{	recurse_f = watchesVarCtrl->SetNextVariable(L, &, var_name, 0/*indent*/, DDT_STACK_LEVEL_C_GLOBALS);
	
		goto next;
	}

	// no longer try registry?
	lua_rawget(L, LUA_REGISTRYINDEX);
	if (!lua_isnil(L, -1))
	{	recurse_f = watchesVarCtrl->SetNextVariable(L, &, var_name, 0/*indent*/, DDT_STACK_LEVEL_REGISTRY);
	
		goto next;
	}

//-----------------------------------------------------------------------------

inline
LX::DataInputStream& operator<<(LX::DataInputStream &dos, const Collected &coll)
{
	return coll.ToStream(dos);
}

//---- On Item Selected -------------------------------------------------------

void	TraceBackListCtrl::OnItemSelected(wxListEvent &e)
{
	int	row = e.GetIndex();
	
	// nop?
	
	e.Skip();
}

//---- Dump Call Stack --------------------------------------------------------

void	DebugFrame::DumpCallStack(const wxString &prefix_str)
{
	if (!prefix_str.IsEmpty())
	{	// output to console window & log
		wxLogMessage("Traceback:");
		
		for (int i = 0; i < m_DaemonStack.m_Levels.size(); i++)
		{
			wxString	s;
			
			if (m_DaemonStack.m_Levels[i].m_Line != -1)
				s = wxString::Format("%s[%2d] %s line %d", prefix_str, i, m_DaemonStack.m_Levels[i].m_OrgFileName, m_DaemonStack.m_Levels[i].m_Line);
			else	s = wxString::Format("%s[%2d] %s (unkown line)", prefix_str, i, m_DaemonStack.m_Levels[i].m_OrgFileName);
			
			wxLogMessage(s);
		}
	}
}

//-----------------------------------------------------------------------------

char	DebugFrame::s_logbuff[2048] = "";

//---- Log Message ------------------------------------------------------------

void	DebugFrame::Log(const char *fmt, ...)
{
	if (fmt == nil)			return;		// should be error?
	
	wxASSERT_MSG(m_OutputTextCtrl, "missing OutputTextCtrl");
	
	va_list	argList;

	va_start(argList, fmt);
	
	#ifdef _WINDOWS
		int	n = ::_vsnprintf(s_logbuff, sizeof(s_logbuff)/*max chars*/, fmt, argList);
	#else
		// risks buffer overrun?
		::vsprintf(s_logbuff, fmt, argList);
	#endif

	va_end(argList);
	
	m_OutputTextCtrl->AppendText(s_logbuff);
}

//-----------------------------------------------------------------------------

void	StyledSourceCtrl::OnDwellStart(wxStyledTextEvent &e)
{
	int	pos = e.GetPosition();
	
	wxLogMessage("OnDwellStart(%d)", pos);
}

void	StyledSourceCtrl::OnDwellEnd(wxStyledTextEvent &e)
{
	int	pos = e.GetPosition();
	
	wxLogMessage("OnDwellEnd(%d)", pos);
}

//---- Call Tip ---------------------------------------------------------------

void	StyledSourceCtrl::ShowCallTip(void)
{
	int		pos = 0;
	wxString	s = "var resolution";
	
	CallTipShow(pos, s);
}

	// mouse dwelling
	void	OnDwellStart(wxStyledTextEvent &e);
	void	OnDwellEnd(wxStyledTextEvent &e);

//---- On Mouse Moved ----------------------------------------------------------

void	SourceCodeListCtrl::OnMouseMoved(wxMouseEvent &e)
{
	wxPoint	mouse_pos = e.GetPosition();
	
	int	flags;
	long	col;
	
	int	ln = HitTest(mouse_pos, flags/*&*/, &col);
	if ((ln != wxNOT_FOUND) && (flags & wxLIST_HITTEST_ONITEMLABEL) && (col == 1))
	{	
		wxLogMessage("mouse pos (%d, %d)", mouse_pos.x, mouse_pos.y);
		
		/*
		wxClientDC	dc(this);
		
		int	trans = dc.DeviceToLogicalX(0);
		
		wxLogMessage("x translation % d", trans);
		*/
		
		/*
		wxScrollHelper	scroll_helper(this);
		
		scroll_helper.AdjustScrollbars();
		
		wxPoint	logical_pos = scroll_helper.CalcUnscrolledPosition(mouse_pos);
		
		wxLogMessage("logical pos (%d, %d)", logical_pos.x, logical_pos.y);
		*/
		
		wxRect	rc;
		bool	ok;
		
		ok = GetSubItemRect(ln, 0/*col*/, rc/*&*/, wxLIST_RECT_LABEL/*wxLIST_RECT_BOUNDS*/);
		if (!ok)	return;		// should log?
		
		int	col_0_x = rc.x;
		
		wxLogMessage("col zero label rect is (%d, %d, %d, %d)", rc.x, rc.y, rc.width, rc.height);
		
		ok = GetSubItemRect(ln, 1/*col*/, rc/*&*/, wxLIST_RECT_BOUNDS);
		if (!ok)	return;		// should log?
		
		int	col_1_x = rc.x;
		
		wxLogMessage("col 1 bounds rect is (%d, %d, %d, %d)", rc.x, rc.y, rc.width, rc.height);
		
		#if 0
			ok = GetSubItemRect(ln, 1/*col*/, rc/*&*/, wxLIST_RECT_BOUNDS);
			if (!ok)	return;		// should log?
			
			wxLogMessage("src tex pos is (%d, %d)", rc.x, rc.y);
		#endif
		
		int	x_offset = mouse_pos.x - col_0_x - col_1_x;
		
		wxLogMessage("x offset pix %d", x_offset);
	}
}

//---- Toggle Selected Breakpoint ---------------------------------------------

void	SourceFileClass::ToggleSelectedBreakpoint(void)
{
	wxASSERT(m_SourceCtrl);
	
	const int	ln = m_SourceCtrl->GetSelectedLine();	// BS!!!
	if (ln != -1)	ToggleBreakpoint(ln);
}

//---- Toggle Breakpoint ------------------------------------------------------

bool	SourceFileClass::ToggleBreakpoint(const int &ln)
{	
	wxASSERT(m_ProjectBreakPoints);
	
	// toggle
	const bool	has_bp = m_ProjectBreakPoints->HasBreakPoint(m_FullFilePath, ln);		// shouldn't use full path?
	
	m_ProjectBreakPoints->SetBreakPoint(m_FullFilePath, ln, !has_bp);
	
	return !has_bp;
}	

//---- Get Name Only ----------------------------------------------------------

inline
wxString	GetNameOnly(const wxString &path_n_name)
{
	wxString	res = path_n_name;
	
	#ifdef __WIN32__
		res.Replace("\\", "/");
	#endif
	
	res = res.AfterLast('/');
	
	if (res.IsEmpty())
		return path_n_name;	// had no slash in it - return original
	else	return res;		// return name only
}

// utils
inline
wxString	ConcatKey(const wxString &fn, const int &ln)
{
	return wxString::Format("%s:%d", fn, ln);
}

//---- Get Source File Class --------------------------------------------------

SourceFileClass*	DebugFrame::GetSourceFileClass(wxString fullpath)
{
	wxASSERT(m_Controller);
	
	#ifdef __WIN32__
		// replace \ with /
		fullpath.Replace("\\", "/");
		// make sure is all lower-case (drive letter's case doesn't seem consistent)
		// fullpath.MakeLower();
	#endif
	
	SourceFileClass	*sfc = m_Controller->GetSFC(fullpath);
	wxASSERT(sfc);
	
	return sfc;
}

struct BreakPointEntry
{	
	wxString	m_ShortName;
	int		m_Line;
};

//---- Is Smaller Than ? ------------------------------------------------------

static
bool	IsSmallerThan(BreakPointEntry bp1, BreakPointEntry bp2)
{
	// compare strings first
	
	// if not same string, return comparison
	if (!bp1.m_ShortName.IsSameAs(bp2.m_ShortName))
		return (bp1.m_ShortName < bp2.m_ShortName);
	
	// otherwise (if is same string), compare lines
	return (bp1.m_Line < bp2.m_Line);
}

//---- Get All (Project) Break Points -----------------------------------------

void	ProjectBreakPoints::GetAllBreakPoints(std::vector<BreakPointEntry> &bp_list) const
{
	bp_list.clear();
	
	for (const auto &it : m_ShortBreakpointSet)
	{
		// get concatenated string
		wxString	bp = it;
		
		// split in two
		wxString	src_str, ln_str;
		
		src_str = bp.BeforeLast(':');
		ln_str = bp.AfterLast(':');
		
		long	ln;
		
		bool	ok = ln_str.ToLong(&ln);
		wxASSERT(ok);
		
		BreakPointEntry	entry;
		
		entry.m_ShortName = src_str;
		entry.m_Line = ln;
		
		bp_list.push_back(entry);
	}
	
	// sort them
	std::sort(bp_list.begin(), bp_list.end(), IsSmallerThan);
}

//---- Serializer -------------------------------------------------------------

class Serializer
{
public:
	// ctor
	Serializer(LuaGlue *glue);
	// dtor
	virtual ~Serializer();
	
	// functions
	void	SerializeCollectedList(const std::string &fn, const std::vector<Collected> &collected_list);
	void	UnserializeCollectedList(const std::string &fn, std::vector<Collected> &collected_list);
	
	void	SerializeClientStack(const std::string &fn, const ClientStack &clientStack);

private:
	
	LuaGlue	*m_LuaGlue;
};

//---- Serialize Collected List -----------------------------------------------

void	Serializer::SerializeCollectedList(const string &fn, const vector<Collected> &collected_list)
{
	ofstream	ofs(fn, ios_base::trunc | ios_base::binary);
	wxASSERT(ofs && ofs.is_open());
	
	FileOutputStream	dos(ofs);
	
	dos << collected_list;
	
	ofs.flush();
}

//---- Unserialize Collected List -----------------------------------------------

void	Serializer::UnserializeCollectedList(const string &fn, vector<Collected> &collected_list)
{
	ifstream	ifs(fn, ios_base::binary);
	wxASSERT(ifs && ifs.is_open());
	
	FileInputStream	dis(ifs);
	
	dis >> collected_list;
}

//---- Serialize Client Stack -------------------------------------------------

void	Serializer::SerializeClientStack(const string &fn, const ClientStack &clientStack)
{
	ofstream	ofs(fn, ios_base::trunc | ios_base::binary);
	wxASSERT(ofs && ofs.is_open());
	
	FileOutputStream	dos(ofs);
	
	dos << clientStack;
	
	ofs.flush();
}

//-----------------------------------------------------------------------------

bool	DDTEventLoop::Pending() const		// NEVER GETS CALLED on Gtk
{
	bool	pending_f = wxGUIEventLoop::Pending();
	if (pending_f)		return pending_f;
	
	// has no pending events
	m_DebugFrame->ProcessCustomQueue();
	
	// query again
	return wxGUIEventLoop::Pending();
}

bool	DDTEventLoop::ProcessIdle()
{
	// has no pending events
	m_DebugFrame->ProcessCustomQueue();
	
	return true;
}

//---- Pop --------------------------------------------------------------------

bool	MessageQueue::Pop(void)
{
	unique_lock<mutex>	lock(m_Mutex);
	
	if (m_Queue.size() == 0)	return false;		// FAILED
	
	m_Queue.pop_front();
	
	return true;
}

//-----------------------------------------------------------------------------

	SetMarginWidth(MARGIN_FOLD, 16);			// fold margin
	SetMarginType(MARGIN_FOLD, wxSTC_MARGIN_SYMBOL);
	SetMarginMask(MARGIN_FOLD, wxSTC_MASK_FOLDERS);
	SetMarginSensitive(MARGIN_FOLD, true);
	
	SetFoldFlags(wxSTC_FOLDFLAG_LINEBEFORE_CONTRACTED | wxSTC_FOLDFLAG_LINEAFTER_CONTRACTED);
	SetProperty("fold", "1");
	SetProperty("fold.compact", "1");
	SetProperty("fold.comment", "1");
	
	wxColour	grey(128, 128, 128);
	
	MarkerDefine(wxSTC_MARKNUM_FOLDEROPEN,    wxSTC_MARK_BOXMINUS, *wxWHITE, grey);
	MarkerDefine(wxSTC_MARKNUM_FOLDER,        wxSTC_MARK_BOXPLUS,  *wxWHITE, grey);
	MarkerDefine(wxSTC_MARKNUM_FOLDERSUB,     wxSTC_MARK_VLINE,    *wxWHITE, grey);
	MarkerDefine(wxSTC_MARKNUM_FOLDERTAIL,    wxSTC_MARK_LCORNER,  *wxWHITE, grey);
	MarkerDefine(wxSTC_MARKNUM_FOLDEREND,     wxSTC_MARK_BOXPLUSCONNECTED,  *wxWHITE, grey);
	MarkerDefine(wxSTC_MARKNUM_FOLDEROPENMID, wxSTC_MARK_BOXMINUSCONNECTED, *wxWHITE, grey);
	MarkerDefine(wxSTC_MARKNUM_FOLDERMIDTAIL, wxSTC_MARK_TCORNER,  *wxWHITE, grey);

//-----------------------------------------------------------------------------

	// Get the items in the global "wx" table for autocompletion
	if not wxkeywords then
	local keyword_table = {}
	for index, value in pairs(wx) do
		table.insert(keyword_table, "wx."..index.." ")
	end

	table.sort(keyword_table)
	wxkeywords = table.concat(keyword_table)
	SetKeyWords(5, wxkeywords)

// EVT_STC_STYLENEEDED(	-1,	StyledSourceCtrl::OnStyleNeeded)

void	OnStyleNeeded(wxStyledTextEvent &e);

//---- On Style Needed event --------------------------------------------------

void	StyledSourceCtrl::OnStyleNeeded(wxStyledTextEvent &e)
{
	wxLogMessage("OnStyleNeeded(%s)", e.GetText());
}

//---- On Set Breakpoint (from UI) --------------------------------------------

void	SourceFileClass::OnSetBreakpoint(const int &ln, const bool &f)
{
	wxASSERT(m_DebugFrame);
	
	// (is actually a TOGGLE)
	ProjectBreakPoints &pbp = m_DebugFrame->GetProjBreakpoints();
	
	// should get flag from LOGIC (not UI state)
	bool	current_bp_f = pbp.HasBreakPoint(GetShortName(), ln);
	
	pbp.SetBreakPoint(GetShortName(), ln, !current_bp_f);
}

//---- Update Breakpoint Icon -------------------------------------------------

void	StyledSourceCtrl::UpdateBreakpointIcon(const int &ln, const bool &f)
{	
	// offset back DOWN for render (UI)
	MarkerDelete(ln - 1, BREAKPOINT_MARKER);
	
	if (f)	MarkerAdd(ln - 1, BREAKPOINT_MARKER);
}

//---- Update Breakpoint Icon -------------------------------------------------

void	SourceFileClass::UpdateBreakpointIcon(const int &ln, const bool &f)
{
	wxASSERT(m_SourceCtrl);
	m_SourceCtrl->UpdateBreakpointIcon(ln, f);
}

//---- Update Breakpoint Icon -------------------------------------------------

void	SourceCodeListCtrl::UpdateBreakpointIcon(const int &ln, const bool &f)
{
	wxLogMessage("SourceCodeListCtrl::UpdateBreakpointIcon(ln %d = %s", ln, f ? "true" : "false");
	
	// is LOGICAL line ?
	SetItemImage(ln - 1, f ? DBGF_ID_BITMAP_RED_DOT : DBGF_ID_BITMAP_EMPTY_PLACEHOLDER);	
}

//-----------------------------------------------------------------------------

OutputTextCtrl

#ifdef __WIN32__
	time_t		t = wxDateTime::GetTimeNow();
	struct tm	*now = ::localtime(&t);
	
	// from MSDN
	struct _timeb	tstruct;
	_ftime(&tstruct);

	const wxString	t_stamped = wxString::Format("%02d:%02d:%02d:%03d: %s", now->tm_hour, now->tm_min, now->tm_sec, tstruct.millitm, text);

	if (m_OutputToVCDebuggerFlag)		::OutputDebugString(t_stamped);
	
	// call base
	wxTextCtrl::AppendText(t_stamped);

#else
{	
	#if 0
	wxDateTime	unow = wxDateTime::UNow();
	
	const auto	t_point = system_clock::now();		// is "time_t" (abstract)
	const auto	t_duration = t_point.time_since_epoch();
	auto	hh = duration_cast<hours>(t_duration);
	auto	mm = duration_cast<minutes>(t_duration);
	auto	ss = duration_cast<seconds>(t_duration);
	auto	ms = duration_cast<milliseconds>(t_duration);
	time_t	now_time_t = system_clock::to_time_t(t_point);
	
	// Map to C API
	// static std::time_t	to_time_t(const time_point& __t) noexcept
	// {
	//	return std::time_t(duration_cast<chrono::seconds>	(__t.time_since_epoch()).count());
	// }


	tm	*tm_struct = localtime(&now_time_t);
	
	char	buff[128];
	#size_t	sz_written = strftime(&buff[0], sizeof(buff), "%H:%M:%S", tm_struct);
	
	const wxString	t_stamped(&buff[0], sz_written);
	
	wxString	t_stamp;
	
	t_stamp = unow.Format("%H:%M:%S:%%03d");
	t_stamp += wxString::Format("%03d ", (int) unow.GetMillisecond());
	
	wxTextCtrl::AppendText(t_stamp + text);
	#endif
	
	// call base
	wxTextCtrl::AppendText(text);
#endif

//---- vector<wxColour> -------------------------------------------------------

	// to use COLOR_MODE (enum class) as index to []

class ColorVector: public std::vector<wxColour>
{
public:
	
	// ctor
	ColorVector(std::initializer_list<wxColour> li)
		: std::vector<wxColour>(li)
	{
	}
	
	const wxColour& operator[](const COLOR_MODE &clr_t)
	{
		const size_t	ind = static_cast<size_t>(clr_t);
		
		return at(ind);
	}	
};

const wxColour	clr = s_ColourLUT[clr_t];

//-----------------------------------------------------------------------------

	
	MillisecLogFormatter	*log_fmt = new MillisecLogFormatter();
	wxLog	*activeLog = wxLog::GetActiveTarget();
	// sets dialog log AND chain to previous file log
	wxLogTextCtrl	*logTextCtrl = new wxLogTextCtrl(m_OutputTextCtrl);
	// set log formatter on earliest target
	// if (!activeLog)		activeLog = logTextCtrl;
	wxASSERT(activeLog);
	// chain log in wxclient application
	// m_LogChain = new wxLogChain(logTextCtrl);
	m_LogInterposer = new LogInterposer(m_OutputTextCtrl);
	m_LogInterposer->SetFormatter(log_fmt);
	m_LogInterposer->SetLogToVCDebugger(log_to_VC_f);
	// m_LogChain->SetFormatter(log_fmt);
	// DON'T use stream redirector, requires wx to be recompiled with wxUSE_STD_IOSTREAM set to 1, then only works on std::cout
	// m_StreamToTextRedirector = new wxStreamToTextRedirector(m_OutputTextCtrl);

//-----------------------------------------------------------------------------

	const char	*name = ::strrchr(ar->source, '/');
	if (!name)
	{	
		// didn't find forward slash, try back slash
		name = ::strrchr(ar->source, '\\');	
		
		if (!name)
		{	// didn't find either slash, filename is 'as is'
			name = ar->source;
		}
		else	name++;		// (skip past '\')
	}
	else	name++;			// (skip past '/')

//-----------------------------------------------------------------------------

	m_Serializer.SerializeCollectedList("locals.bin", m_CollectedList);
	
	CollectedList		collectedList_unser;
	
	m_Serializer.UnserializeCollectedList("locals.bin", collectedList_unser/*&*/);
	
	m_Serializer.SerializeCollectedList("locals2.bin", m_CollectedList);

//---- Request Lua Stack ------------------------------------------------------

void	LuaGlue::RequestLuaStack(void)
{
	MemoryOutputStream	mos;
	
	mos << DAEMON_MSG::REPLY_STACK;
			
	m_DaemonStack.ToClientStack().ToStream(mos);
	
	m_DebugFrame->AddMessage(mos);
}

//---- Notify ClientStack -----------------------------------------------------

void	LuaGlue::NotifyClientStack(void)
{
	shared_ptr<ClientStack>	clientStack = m_DaemonStack.GenerateClientStack();
	wxASSERT(clientStack);
	
	MemoryOutputStream	mos;
	
	mos << DAEMON_MSG::NOTIFY_STACK;
	
	clientStack->ToStream(mos);
	
	m_DebugFrame->AddMessage(mos);
	
	// (buffers can lapse here)
}

//-----------------------------------------------------------------------------

// m_DaemonStack.m_VisibleLevel = ((m_EntryType == ENTRY_TYPE::C_BREAKPOINT) || (m_EntryType == ENTRY_TYPE::ERROR)) ? 1 : 0;
	
	if (predicted_level != m_DaemonStack.m_VisibleLevel)
	{
		wxLogError("stack vis levels %d vs %d", predicted_level, m_DaemonStack.m_VisibleLevel);
	}
	
//---- (forwarder) ------------------------------------------------------------

int	DebugFrame::lua_pcall_ddt(lua_State *L, int nargs, int nresults)
{
	wxASSERT_MSG(L, "lua_State was not initialized!");
	wxASSERT(m_ProjectPrefs);
	wxASSERT_MSG(m_ProjectPrefs->IsLoaded(), "SetLuaProjectName() was not called!");
	
	return m_LuaDaemon->StartLua(L, nargs, nresults);
}

//---- request delayed wake-up (IMPLEMENTATION) -------------------------------

void	DebugFrame::WakeUpDaemon(void)
{
	// ask event handler to wake daemon up
	wxQueueEvent(this, new wxThreadEvent(wxEVT_THREAD, DBGF_ID_REQUEST_DAEMON_TICK));
}

//---- Do Daemon Tick ---------------------------------------------------------

void	DebugFrame::OnRequestDaemonTick(wxThreadEvent &e)
{
	// wx 3.0 has lambdas :)
	// wxTheApp->CallAfter([this]{m_LuaGlue.TickDaemon();});
	m_LuaDaemon->Tick();
}

//-----------------------------------------------------------------------------

	ifs.seekg(0, ios_base::end);
	assert(ifs.good());
	m_Size = ifs.tellg();
	assert(ifs.good());
	
	// rewind
	ifs.seekg(0, ios_base::beg);
	assert(ifs.good());

	
	const size_t	read_sz = ifs.read(&buff[0], m_Size).gcount();
	assert(ifs.good());
	assert(read_sz == m_Size);
	
	m_MD5 = CalcBuffMD5(buff);
	
//---- Calc Buffer MD5 Hash ---------------------------------------------------

string	File::CalcBuffMD5(const vector<char> &buff) const
{
	MD5		hasher;
	HL_MD5_CTX	context;
	
	hasher.MD5Init(&context);
	hasher.MD5Update(&context, (uint8_t*) &buff[0], buff.size());

	// finalize hash
	unsigned char digest[16];
	
	hasher.MD5Final(digest, &context);
	
	// convert binary digest to (lowercase) hex string
	//   format gets reset after each output (dunno why)
	//   Stroustrup says "binary I/O is system specific" @ chapter 38.2.1 (bullshit)
	ostringstream	md5_stream;
	
	for (int i = 0; i < sizeof(digest); i++)
		md5_stream << hex << setfill('0') << setw(2) << (int) digest[i];
	
	const string	md5 = md5_stream.str();
	
	return md5;
}

	// workaround Hashlib bug (uses #if instead of #ifdef)
	#define __MINGW32__	0
	#define _MSC_VER	0

//-----------------------------------------------------------------------------

//--- Dir native --------------------------------------------------------------

class Dir_native: public Dir
{
public:
	// ctor
	Dir_native(const string &path, DIR *d)
		: Dir(path)
	{
		assert(d);
		m_DIR = d;
	}
	// dtor
	~Dir_native()
	{
		if (m_DIR)
		{	closedir(m_DIR);
			m_DIR = nil;
		}
	}

private:
	
	::DIR	*m_DIR;
};

// static
Dir*	Dir::New(const string &path)
{
	if (path.empty())	return nil;		// error
	
	DIR	*d = opendir(path.c_str());
	if (!d)			return nil;		// error
	
	Dir_native	*dn = new Dir_native(path, d);
	return dn;
}

//-----------------------------------------------------------------------------

// shared_ptr<>
	
	make_shared<ofstream>(filepath, ios_base::binary);
	
//-----------------------------------------------------------------------------

#include <cstdint>
#include <vector>
#include <string>
#include <fstream>
#include <memory>

#include "ddt/DataStream.h"

namespace LX
{

using namespace std;

// implement DataInputStream for FILE
class FileInputStream: public DataInputStream
{
public:
	FileInputStream(ifstream &ifs)
		: m_is(ifs)
	{
	}
	
	// implementations
	bool	IsOk(void) const
	{
		return (!m_is.eof() && !m_is.bad());
	}
	
	uint8_t	get_LL(void)
	{	
		ifstream::char_type	c;
		
		const size_t	actually_read = m_is.get(c/*&*/).gcount();
		assert(1 == actually_read);
		
		return (uint8_t) c;
	}
	
	void	read_LL(uint8_t *p, const size_t &sz)
	{
		const size_t	actually_read = m_is.read((ifstream::char_type *)p, sz).gcount();
		assert(sz == actually_read);
	}
	
	void	peek_LL(uint8_t *p, const size_t &sz) const
	{
		// save current pos
		const auto	saved_pos = m_is.tellg();
		
		// read data
		const size_t	actually_read = m_is.read((ifstream::char_type *)p, sz).gcount();
		assert(sz == actually_read);
		
		// restore position
		m_is.seekg(saved_pos);
		
	}
	
private:
	
	ifstream	&m_is;
};

//-----------------------------------------------------------------------------

	// make internal copy
	MemoryInputStream(const uint8_t *p, const size_t &sz, bool copy_local_f)
		: m_InternalBuff(sz, 0), m_Data(&m_InternalBuff[0]), m_Total(sz)
	{
		m_Pos = 0;
		
		// copy after ctor (space was allocated before)
		::memcpy(&m_InternalBuff[0], p, sz);
	}
	
	// std::vector<uint8_t>	m_InternalBuff;
	
	
	/*
	ofStream_Sink	*sink = new ofStream_Sink("/home/plaufenb/demo.ddt");
	
	m_FOS = new DataOutputStream(sink);
	*/

// std::ofstream Sink implementation

class ofStream_Sink : public dSink
{
public:
	// ctor
	ofStream_Sink(const string &filepath)
		: m_os { filepath, ios_base::binary }
	{
		m_FilePath = filepath;
		
	}
	
	void	Rewind(void)
	{
		m_os.seekp(0, ios_base::beg);
	}
	
	void	Flush(void)
	{
		m_os.flush();
	}
	
	size_t	GetLength(void)
	{
		// returns a "file position" object
		return m_os.tellp();
	}
	
	void	put_LL(const uint8_t &c)
	{
		m_os.put((const ofstream::char_type)c);		// REDUNDANT
	}
	
	void	write_LL(const uint8_t *p, const size_t &sz)
	{
		m_os.write((const ofstream::char_type *)p, sz);
	}
	
private:	
	
	string		m_FilePath;
	ofstream	m_os;
};


//---- Save Sources -----------------------------------------------------------

void	ProjectPrefs::SaveSources(void)
{
	wxASSERT(m_Controller);
	
	StringList	source_short_paths = m_Controller->GetSFCPaths();
	StringList	project_rel_paths;
	
	// make paths relative to prefs
	for (auto it : project_source_paths)
	{
		const wxString	full_path = it;
		
		wxFileName	cfn(full_path);
		bool	ok = cfn.MakeRelativeTo(m_PrefsDir);
		wxASSERT(ok);
		
		project_rel_paths.push_back(cfn.GetFullPath());
	}
	
	SaveGroupEntries("/project_sources", project_rel_paths);
}

//---- Save Sources -----------------------------------------------------------

void	ProjectPrefs::SaveSources(void)
{
	wxASSERT(m_Controller);
	
	StringList	project_rel_paths;
	
	// make paths relative to prefs
	for (auto it : project_source_paths)
	{
		const wxString	full_path = it;
		
		wxFileName	cfn(full_path);
		bool	ok = cfn.MakeRelativeTo(m_PrefsDir);
		wxASSERT(ok);
		
		project_rel_paths.push_back(cfn.GetFullPath());
	}
	
	SaveGroupEntries("/project_sources", project_rel_paths);
}

//---- Load Sources -----------------------------------------------------------

bool	ProjectPrefs::LoadSources(void)
{
	wxASSERT(m_Config);
	wxASSERT(m_Controller);
	
	m_Controller->DeleteAllSFCs();
	
	StringList	source_entries = LoadGroupEntries("/project_sources");
	if (source_entries.empty())	return true;
	
	vector<wxString>	source_list, missing_sources;
	
	// check sources exist
	for (auto it : source_entries)
	{
		wxString	rel_fpath = it;
		
		wxFileName	cfn(rel_fpath);
		// stored as relative -> make it absolute
		cfn.MakeAbsolute(m_PrefsDir);
		
		wxString	fullpath = cfn.GetFullPath();
		
		if (cfn.FileExists())	source_list.push_back(fullpath);
		else
		{	// file not found
			const int	res = PromptFileLocation(fullpath/*&*/);
			if (res == wxCANCEL)		return false;		// aborted
			else if (res == wxYES)
			{	// replace with new
				source_list.push_back(fullpath);
			}
			else
			{	// ignore
				missing_sources.push_back(fullpath);
			}
			
			// mark project as dirty so will save new filename
			// m_DirtyFlag = true;
		}
	}
	
	// show message with missing sources
	if (missing_sources.size() > 0)
	{
		wxString	msg = "The following project sources are missing:\n\n";
		
		for (const auto it : missing_sources)	msg.Append(it + "\n");
		
		int	res = ::wxMessageBox(msg, "Warning",  wxOK | wxICON_WARNING);
	}
	
	// load source files
	for (int i = 0; i < source_list.size(); i++)
	{	
		wxFileName	cfn(source_list[i]);
		wxASSERT(cfn.FileExists());
		
		// instantiate SFC
		SourceFileClass	*sfc = m_Controller->NewSFC(cfn.GetFullPath());
		wxASSERT_MSG(sfc, "project source file not found");
	}
	
	return true;
}

//---- Close Project ----------------------------------------------------------

void	ProjectPrefs::CloseProject(void)
{
	wxASSERT(m_Controller);
	
	m_Controller->DeleteAllSFCs();
	
	wxDELETE(m_Config);
	
	m_ProjectName.clear();
	m_PrefsDir.clear();
	m_DirtyFlag = false;
}

//-----------------------------------------------------------------------------

	// CloseProject();
	
	#if 0
	LX::Dir	dir("/home/plaufenb");
	
	vector<string>	files = dir.GetFiles();
	int	i = 0;
	
	for (const auto it : files)
	{
		wxLogMessage(" file[%3d] \"%s\"", i++, wxString(it));
	}
	
	vector<string>	subdirs = dir.GetFiles();
	i = 0;
	
	for (const auto it : subdirs)
	{
		wxLogMessage(" dir[%3d] \"%s\"", i++, wxString(it));
	}
	
	if (prefs_folderpath.IsEmpty())
	{	// no dir? use working directory
		m_PrefsDir = ::wxGetCwd();
	}
	else
	{	// user-defined prefs path
		m_PrefsDir = prefs_folderpath;
	}
	
//-----------------------------------------------------------------------------

	bool	LoadSources(void);		
	void	LoadBreakpoints(void);
	void	LoadWatchVariables(void);
	
	void	SaveSources(void);
	void	SaveBreakpoints(void);
	void	SaveWatchVariables(void);
	
	// StringList	LoadGroupEntries(const wxString &group);
	// void	SaveGroupEntries(const wxString &group, const StringList entries);
	
	// int	PromptFileLocation(wxString &fn);
	
	// wxFileConfig	*m_Config;
	// wxString	m_ProjectName;
	// wxString	m_PrefsDir;

	cfn.MakeAbsolute();
	
	project name is without extension
	m_ProjectName = cfn.GetName();
	
	// add path, change extension
	cfn.AppendDir(DEBUG_DIR_NAME); 
	cfn.SetExt("ldbg");
	
	// if debug directory doesn't exist, create it
	wxString	dbg_dir = cfn.GetPath();
	
	#ifdef __WIN32__
		dbg_dir.Replace("\\", "/");
	#endif
	
	if (!::wxDirExists(dbg_dir))	wxFileName::Mkdir(dbg_dir, wxS_DIR_DEFAULT, wxPATH_MKDIR_FULL);
	
	wxString	dbg_filename = cfn.GetFullPath();
	
	#ifdef __WIN32__
		dbg_filename.Replace("\\", "/");
	#endif
	
	wxLogMessage("PROJECT PREFS FILE IS \"%s\"", dbg_filename);
	
	// get config file
	m_Config = new wxFileConfig("InhanceDebugger", "Inhance", dbg_filename, ""/*ignore*/, wxCONFIG_USE_LOCAL_FILE);
	wxASSERT_MSG(m_Config, "couldn't create project wxFileConfig");

#if 0

//---- Prompt File Location ---------------------------------------------------

int	ProjectPrefs::PromptFileLocation(wxString &fn)
{
	wxASSERT(m_ClientFrame);
	
	wxString	locate_q = wxString::Format("File \"%s\" not found, would you like to locate it?", fn);
	
	int	res = ::wxMessageBox(locate_q, "Lua Debugger Error", wxYES_NO | wxCANCEL | wxICON_ERROR);
	if (res != wxYES)		return res;
	
	// try to locate it
	wxString	title = wxString::Format("Please locate the file \"%s\"", fn);
	
	wxString	new_filename = ::wxFileSelector(	title,
								""/*dir*/, ""/*filename*/, "","ddt files (*.ddt)|*.ddt|All files (*.*)|*.*",
								wxFD_SAVE | wxFD_OVERWRITE_PROMPT,
								m_ClientFrame);		// parent
	if (new_filename.IsEmpty())
	{	// relocation was canceled
		return wxCANCEL;
	}
	
	// reassign
	fn = new_filename;
	
	return wxYES;
}


//---- Load Group Entries -----------------------------------------------------

StringList	ProjectPrefs::LoadGroupEntries(const wxString &group)
{
	wxASSERT(m_Config);
	
	StringList	entry_list;
	
	if (!m_Config->HasGroup(group))		return entry_list;
	
	m_Config->SetPath(group);
	
	// enumeration variables
	wxString	key;
	long		cookie;
	
	bool	cont_f = m_Config->GetFirstEntry(key/*&*/, cookie/*&*/);
	while (cont_f)
	{
		wxString	val;
		
		m_Config->Read(key, &val, "");
		wxASSERT(!val.IsEmpty());
		
		entry_list.push_back(val);
		
		cont_f = m_Config->GetNextEntry(key/*&*/, cookie/*&*/);
	}
	
	// restore path
	m_Config->SetPath("/");
	
	return entry_list;
}

//---- Save Group Entries -----------------------------------------------------

void	ProjectPrefs::SaveGroupEntries(const wxString &group, const StringList entries)
{
	wxASSERT(m_Config);
	
	// clear previous entries
	m_Config->DeleteGroup(group);
	
	// write to config
	for (int i = 0; i < entries.size(); i++)
	{
		const wxString	key = wxString::Format("%s/entry%d", group, i);
		const wxString	val = entries[i];
		
		m_Config->Write(key, val);
	}
	
	m_Config->Flush();
}

#if 0

//---- Load Sources -----------------------------------------------------------

bool	ProjectPrefs::LoadSources(void)
{
	wxASSERT(m_Config);
	wxASSERT(m_Controller);
	
	m_Controller->DeleteAllSFCs();
	
	StringList	source_entries = LoadGroupEntries("/project_sources");
	if (source_entries.empty())	return true;
	
	vector<wxString>	source_list, missing_sources;
	
	// check sources exist
	for (auto it : source_entries)
	{
		wxString	rel_fpath = it;
		
		wxFileName	cfn(rel_fpath);
		// stored as relative -> make it absolute
		cfn.MakeAbsolute(m_PrefsDir);
		
		wxString	fullpath = cfn.GetFullPath();
		
		if (cfn.FileExists())	source_list.push_back(fullpath);
		else
		{	// file not found
			const int	res = PromptFileLocation(fullpath/*&*/);
			if (res == wxCANCEL)		return false;		// aborted
			else if (res == wxYES)
			{	// replace with new
				source_list.push_back(fullpath);
			}
			else
			{	// ignore
				missing_sources.push_back(fullpath);
			}
			
			// mark project as dirty so will save new filename
			// m_DirtyFlag = true;
		}
	}
	
	// show message with missing sources
	if (missing_sources.size() > 0)
	{
		wxString	msg = "The following project sources are missing:\n\n";
		
		for (const auto it : missing_sources)	msg.Append(it + "\n");
		
		int	res = ::wxMessageBox(msg, "Warning",  wxOK | wxICON_WARNING);
	}
	
	// load source files
	for (int i = 0; i < source_list.size(); i++)
	{	
		wxFileName	cfn(source_list[i]);
		wxASSERT(cfn.FileExists());
		
		// instantiate SFC
		SourceFileClass	*sfc = m_Controller->NewSFC(cfn.GetFullPath());
		wxASSERT_MSG(sfc, "project source file not found");
	}
	
	return true;
}


// derived
std::string	ReadString(void)
{
	// read string length (swap is implicitly handled)
	const size_t	sz = Read32();
	if (sz == 0)	return std::string();	// empty
	
	// assign to string
	std::string	s((const char*)m_Data + m_Pos, sz);
	m_Pos += sz;
	
	// and return
	return s;
}


//---- On New Project ---------------------------------------------------------

void	ClientFrame::OnNewProject(wxCommandEvent &e)
{
	wxFileDialog	dlg(	this,
				"Select New Project",
				"",			// default dir
				"",			// default file
				"DDT Projects (*.ddt)|*.ddt|All files (*.*)|*.*",		// which file types to show
				wxFD_OPEN | wxFD_SAVE);
				
	int	res = dlg.ShowModal();
	if (res == wxID_CANCEL)		return;
	
	wxLogWarning("FLUSH ALL CURRENT SETTINGS");
}

	// set column name
	wxListItem	itemCol;
	
	itemCol.SetText(wxString::Format("Project \"%s\"", proj_name));
	itemCol.SetImage(DBGF_ID_BITMAP_CLOSE_TAB);
	itemCol.SetMask(wxLIST_MASK_TEXT | wxLIST_MASK_IMAGE);
	
	bool	ok = SetColumn(0, itemCol);
	wxASSERT(ok);
	
//---- On Show Project Sources ------------------------------------------------

void	ClientFrame::OnShowProjectSources(void)
{
	wxASSERT(m_ProjectPrefs);
	
	// remove this crap ? FIXME
	const int	notepage_index = m_BottomNotebook->GetSelection();
	if (notepage_index != NOTEBOOK_PAGE_PROJECT)	return;
	
	m_ProjectViewCtrl->UpdateProjectView(project_name);		// uses BAD push model -- FIXME
}

//-----------------------------------------------------------------------------

	wxUpdateUIEvent	e(DBGF_ID_REFRESH_STACK);

	const wxString	payload_s = wxString::Format("clientStack:%d", (int)m_ClientStack->NumLevels());
	e.SetString(payload_s);

	wxQueueEvent(m_TraceBackCtrl, e.Clone());


//---- Refresh SFC Mappings ---------------------------------------------------

void	ProjectListCtrl::RefreshMappings(const bool &delete_f)
{
	assert(m_Controller);
	
	vector<SourceFileClass*>	sfc_instances  = m_Controller->GetSFCInstances();
	
	if (delete_f)	DeleteAllItems();
	
	int	i = 0;
	for (auto it : sfc_instances)
	{
		// associate item with SFC
		SourceFileClass	*sfc = sfc_instances[i];
		SetItemData(i++, (wxUIntPtr)sfc);
	}
}

static
int	s_CalcDissenter(StringList per_source_fpath)
{
	// find best COMMON root in case a file is in a Howard Johnson in a valley shouting across mountain peaks
	//   reparse all paths in parallel starting from partition root, stop when differ
	
	for (int i = 0; i < per_source_fpath.size(); i++)
		wxLogMessage("[%2d] \"%s\"", i, wxString(per_source_fpath[i]));
	
	// last entry is reference
	string	ref_source = per_source_fpath.back();
	per_source_fpath.pop_back();
	bool	done_f = false;
	int	mismatch_ind = -1;
	string	mismatch_s;
	
	for (int char_ind = 0; !done_f; char_ind++)
	{
		const char	c_ref = ref_source.at(char_ind);
		
		for (auto it : per_source_fpath)
		{
			if (c_ref == it.at(char_ind))	continue;
			
			// mismatch
			mismatch_s = it;
			mismatch_ind = char_ind;
			done_f = true;
			break;
		}
		
		if (done_f)	break;
	}
	
	wxLogMessage("%s", ref_source);
	wxLogMessage("%s", mismatch_s);
	wxLogMessage("%s^", wxString(' ', mismatch_ind - 1));
	
	wxLogMessage(" index %d", mismatch_ind);
	
	return mismatch_ind;
}

class OverlayDnD: public wxFrame
{
public:
	// ctor
	OverlayDnD(Controller *controller, const wxString &appPath)
		: wxFrame(nil/*no parent*/, FRAME_ID_DND_OVERLAY, "DnD", wxDefaultPosition, wxSize(-1, -1), wxSTAY_ON_TOP | wxFRAME_NO_TASKBAR | wxBORDER_NONE)
	{
		assert(controller);
		
		m_Controller = controller;
		
		m_Banner = new wxBannerWindow(this, wxTOP);
		
		// Hide();
		
		wxFileName	cfn(appPath, "big_file_icon.png");
		assert(cfn.IsOk());
		
		cfn.AppendDir("Client");
		cfn.AppendDir("res");
		cfn.Normalize();
		
		wxString	path = cfn.GetFullPath();
		assert(cfn.FileExists());
		
		m_FileBitmap.LoadFile(path, wxBITMAP_TYPE_PNG);
		assert(m_FileBitmap.IsOk());
		
		const wxSize	bm_sz = m_FileBitmap.GetSize();
		
		wxLogMessage("bitmap size %d x %d", bm_sz.x, bm_sz.y);
		
		m_Banner->SetBitmap(m_FileBitmap);
		
		SetClientSize(bm_sz);
		
		SetTransparent(128);
	}
	
	~OverlayDnD()
	{	
		wxLogMessage("OverlayDnD DTORed");
	}
	
	// implementation
	bool	ShouldPreventAppExit()	{ return false; }
		
	Controller	*m_Controller;
	wxBannerWindow	*m_Banner;
	wxBitmap	m_FileBitmap;
};

//---- FileDropTarget implementation

class MyFileDropTarget: public wxFileDropTarget		// public wxDropTarget
{
public:
	// ctor
	MyFileDropTarget(Controller *controller, ProjectListCtrl *projListCtrl, OverlayDnD *overlayDnd)
	{
		wxASSERT(controller);
		wxASSERT(projListCtrl);
		wxASSERT(overlayDnd);
		
		m_Controller = controller;
		m_ProjectListCtrl = projListCtrl;
		
		m_ProjectListCtrl->SetDropTarget(this);
		
		m_OverlayFrame = overlayDnd;
	}
	
	// dtor
	~MyFileDropTarget()
	{
		m_ProjectListCtrl->SetDropTarget
		
		m_OverlayFrame = nil;
		
		wxLogMessage("MyFileDropTarget DTORed");
	}
	
	// to change cursor or whatever during drag
	wxDragResult OnDragOver(wxCoord x, wxCoord y, wxDragResult def)
	{	
		wxPoint	screen_pt = m_ProjectListCtrl->ClientToScreen(wxPoint(x, y));
		
		m_OverlayFrame->Move(screen_pt.x, screen_pt.y);
		
		switch (def)
		{	
			case wxDragError:
				
				wxLogMessage("error prevented the d&d operation from completing");
				break;
				
			case wxDragNone:
				
				// wxLogMessage("drag target didn't accept the data");
				break;
			case wxDragCopy:
				
				wxLogMessage("wxDragCopy");
				break;
				
			case wxDragMove:

				// wxLogMessage("the data was successfully moved");
				break;
				
			case wxDragCancel:
				
				// wxLogMessage("the operation was cancelled by user (not an error)");
				break;
				
			default:
			
				break;
		}
		
		return def;
	}
	
	void	OnEnter(void)
	{
		m_OverlayFrame->Show();
	}
	
	void	OnLeave(void)
	{
		m_OverlayFrame->Hide();
	}

	// Override these to indicate what kind of data you support:
	/*
	size_t		GetFormatCount(void) const
	{
		return 1;
	}
	
	wxDataFormat	GetFormat(size_t n) const
	{
	}

	// to react to the drop
	wxDragResult	OnData(wxCoord x, wxCoord y, wxDragResult def)
	{
		if (!GetData())		return wxDragNone;
		
	}
	*/
	
	bool	OnDropFiles(wxCoord x, wxCoord y, const wxArrayString &filenames)
	{
		const size_t	n_files = filenames.GetCount();
		
		wxLogWarning("dropped %lu files", n_files);
		
		return true;
	}
	
private:

	Controller	*m_Controller;
	ProjectListCtrl	*m_ProjectListCtrl;
	OverlayDnD	*m_OverlayFrame;
};

//---- Calc Bounding Rects ----------------------------------------------------

void	MapListCtrl::CalcBoundingRects(void)
{
	m_ColRect.clear();
	
	for (int i = 0; i < 3; i++)
	{	wxRect	rc;
	
		GetSubItemRect(0, i, rc/*&*/, wxLIST_RECT_BOUNDS);
		
		m_ColRect.push_back(rc);
	}
}

//---- Find Column ------------------------------------------------------------

int	MapListCtrl::FindCol(const wxPoint &pt) const
{
	for (int i = 0; i < m_ColRect.size(); i++)
	{
		const wxRect	&rc = m_ColRect[i];
		
		if ((pt.x >= rc.GetLeft()) && (pt.x < rc.GetRight()))	return i;
	}
	
	return -1;	// not found
}

//---- On Mouse Left Down -----------------------------------------------------

void	MapListCtrl::OnMouseLeftDown(wxMouseEvent &e)
{
	int	flags;
	
	const int	row = HitTest(e.GetPosition(), flags/*&*/);		// getting column from hittest is win-only?
	if ((flags & wxLIST_HITTEST_ONITEM) && (row == m_Cnt))
	{
		int	col = FindCol(e.GetPosition());
		
		wxLogMessage("OnMouseLeftDown(%d, %d)", row, col);
		
		// EditLabel(row);
		e.Skip();
	}
	else	e.Skip();
}

void	MapListCtrl::OnItemSelected(wxListEvent &e)
{
	const int	row = e.GetIndex();
	const int	col = e.GetColumn();
	
	wxLogMessage("OnItemSelected(%d, %d)", row, col);
}

//---- On List Item Activated -------------------------------------------------

void	MapListCtrl::OnItemActivated(wxListEvent &e)
{
	wxASSERT(m_Controller);
	
	const int	row = e.GetIndex();
	const int	col = e.GetColumn();
	
	if (row == m_Cnt)	EditLabel(row);
	
	// wxLogMessage("double-clicked %d, %d", row, col);
}

//---- On List Item Edit End --------------------------------------------------

void	MapListCtrl::OnListItemEditEnd(wxListEvent &e)
{
	if (e.IsEditCancelled())	return;			// canceled editing
	
	const int	row = e.GetIndex();
	const wxString	name = e.GetLabel();
	
	wxLogMessage(" OnListItemEditEnd(%d, \"%s\")", row, name);
}

//-----------------------------------------------------------------------------

	m_ImageList = new wxImageList(DDT_ICON_SIZE, DDT_ICON_SIZE);
	const wxSize icon_sz = wxSize(DDT_ICON_SIZE, DDT_ICON_SIZE);
	// same order as icon enums (above)
	m_ImageList->Add(wxArtProvider::GetIcon(wxART_NORMAL_FILE, wxART_LIST, icon_sz));
	m_ImageList->Add(wxArtProvider::GetIcon(wxART_FOLDER, wxART_LIST, icon_sz));
	m_ImageList->Add(wxArtProvider::GetIcon(wxART_FOLDER_OPEN, wxART_LIST, icon_sz));
	// (doesn't take ownership)
	SetButtonsImageList(m_ImageList);
		
//-----------------------------------------------------------------------------
		
	AppendItem(m_LuaRootItem, "test1", TreeCtrlIcon_File);
	AppendItem(m_LuaRootItem, "test2", TreeCtrlIcon_File);
	AppendItem(m_LuaRootItem, "test3", TreeCtrlIcon_File);
	AppendItem(m_LuaRootItem, "test4", TreeCtrlIcon_File);

//-----------------------------------------------------------------------------

void	DumpRecursive(StringNode &sn, int level)
{
	const wxString	pad_s(' ', level * 4);
	
	wxLogMessage("[%2d] %s%s", level, pad_s, wxString(sn.Name()));
	
	for (int i = 0; i < sn.NumChildren(); i++)
	{
		DumpRecursive(sn.at(i), level + 1);
	}
}

//-----------------------------------------------------------------------------

wxTreeItemId	item = client_id;
	
	for (int i = 0; i < dirs.Count(); i++)
	{	wxString	subdir = dirs[i];
		
		item = AppendItem(item, subdir, TreeCtrlIcon_Folder, TreeCtrlIcon_FolderSelected);
		
		wxLogMessage(" [%2d] \"%s\"", i, subdir);
	}

//-----------------------------------------------------------------------------

void	NewNode(wxTreeItemId parent_item)
{
	StringNode	*parent_node_p = GetItemStringNode(parent_item);
	
	StringNode	*new_node = & parent_node_p->add(NEW_NODE_NAME);
	
	// how to get wxTreeItemId back ?
	m_NewItem = NULL_TREE_ITEM;
	
	Redraw();
	
	// get parent child itemId ?
	assert(m_NewItem != NULL_TREE_ITEM);
	
	// trigger edit on new node
	EditLabel(m_NewItem);
}

//-----------------------------------------------------------------------------

#define	list_style	(wxLC_REPORT | wxLC_SINGLE_SEL | wxLC_HRULES | wxLC_VRULES)

class OneToOneMapListCtrl : public wxListCtrl
{
public:
	// ctor
	OneToOneMapListCtrl(wxWindow *parent, int id, class MapPanel *map_panel, Controller *controller)
		: wxListCtrl(parent, id, wxDefaultPosition, wxDefaultSize, list_style)
	{
		assert(map_panel);
		assert(controller);
		
		m_MapPanel = map_panel;
		m_Controller = controller;
		
		const wxSize icon_sz = wxSize(DDT_ICON_SIZE, DDT_ICON_SIZE);
		
		m_ImageList = new wxImageList(DDT_ICON_SIZE, DDT_ICON_SIZE);
		m_ImageList->Add(wxArtProvider::GetIcon(wxART_PLUS, wxART_LIST, icon_sz));
		m_ImageList->Add(wxArtProvider::GetIcon(wxART_DELETE, wxART_LIST, icon_sz));		
		SetImageList(m_ImageList, wxIMAGE_LIST_SMALL);
		
		InsertColumn(0, "Client", wxLIST_FORMAT_LEFT);
		InsertColumn(1, "Lua", wxLIST_FORMAT_LEFT);
	}		
	
	void	Redraw(void)
	{
		DeleteAllItems();
		
		// should get mappings from Controller
		
		#ifdef __WIN32__
			const int	AUTO_SZ = wxLIST_AUTOSIZE_USEHEADER;
		#else
			const int	AUTO_SZ = wxLIST_AUTOSIZE;
		#endif
		
		SetColumnWidth(0, AUTO_SZ);
		SetColumnWidth(1, AUTO_SZ);
	}
	
private:
	
	class MapPanel	*m_MapPanel;
	Controller	*m_Controller;
	
	wxImageList	*m_ImageList;
};

//-----------------------------------------------------------------------------

	wxBoxSizer	*h_sizer = new wxBoxSizer(wxHORIZONTAL);
	
	m_MapNameCombo = new wxComboBox(this, COMBO_ID_MAP_NAME, "name");
	
	#define	dir_styl	(wxDIRP_DIR_MUST_EXIST)		// | wxDIRP_SMALL)
	m_MapClientDirPicker = new wxDirPickerCtrl(this, CONTROL_ID_DIR_PICKER, "", "Client Dir", wxDefaultPosition, wxDefaultSize, dir_styl);
	
	m_MapLuaDirCombo = new wxComboBox(this, COMBO_ID_LUA_DIR, "lua dir");
	
	h_sizer->Add(new wxStaticText(this, -1, "Map Name:"), wxSizerFlags().Align(wxALIGN_CENTER_VERTICAL).Border(wxLEFT | wxRIGHT, 4));
	h_sizer->Add(m_MapNameCombo, wxSizerFlags(1).Align(wxALIGN_CENTER_VERTICAL));
	h_sizer->Add(new wxStaticText(this, -1, "Client Dir:"), wxSizerFlags().Align(wxALIGN_CENTER_VERTICAL).Border(wxLEFT | wxRIGHT, 4));
	h_sizer->Add(m_MapClientDirPicker, wxSizerFlags(1).Align(wxALIGN_CENTER_VERTICAL));
	h_sizer->Add(new wxStaticText(this, -1, "Lua Dir:"), wxSizerFlags().Align(wxALIGN_CENTER_VERTICAL).Border(wxLEFT | wxRIGHT, 4));
	h_sizer->Add(m_MapLuaDirCombo, wxSizerFlags(1).Align(wxALIGN_CENTER_VERTICAL));

//-----------------------------------------------------------------------------

void	SetVisibleDirs(StringList &vis_dirs)
{
	m_Visibles.clear();
	if (vis_dirs.size() == 0)	return;
	
	ReCreateTree();
	CollapseTree();
	
	std::unordered_set<wxString, wxStringHash, wxStringEqual>	no_dupe_set;
	
	wxString	first_path;
	
	for (auto fullpath : vis_dirs)
	{
		wxFileName	cfn(fullpath);
		cfn.Normalize();
		assert(cfn.IsOk());
		
		// keep only directory part
		const wxString	path = cfn.GetPath();
		
		if (no_dupe_set.count(path))	continue;	// ignore duplicate
		
		first_path = path;
		
		no_dupe_set.insert(path);
		
		m_Visibles.push_back(path);
	}
	
	assert(!first_path.IsEmpty());
	
	HighlightPath(first_path);
}

//---- Calc Virtual Folders ---------------------------------------------------

bool	ProjectPrefs::CalcVirtualFolders(void)
{
	assert(m_Controller);
	StringList	fullpaths = m_Controller->GetSFCPaths(true/*fullpaths*/);
	if (fullpaths.size() == 0)	return true;
	
	std<string>	slice_n_dice;
	
	sort(fullpaths.begin(), fullpaths.end(), [](const string &s1, const string &s2){return (s1 < s2);});
}

//---- Calc source encapsulations ---------------------------------------------

void	ProjectPrefs::CalcRussianDolls(void)
{
	assert(m_Controller);
	
	m_Containers.clear();
	m_PathToContainer.clear();
	
	StringList	sources_fullpaths = m_Controller->GetSFCPaths(true/*full*/);
	
	const int	n_paths = sources_fullpaths.size();
	if (n_paths == 0)
	{	m_LuaRootDir.Clear();
		return;
	}
	
	if (n_paths == 1)
	{	// 1 entry -> 1 container
		m_Containers.push_back(wxFileName(sources_fullpaths[0]).GetPath());
		m_PathToContainer.push_back(0);
		return;
	}
	
// need at least 2 entries for Russian dolls
	
	// get cfns
	vector<wxFileName>	sorted_cfns;
	
	for (auto it : sources_fullpaths)
	{
		wxFileName	cfn(it);
		assert(cfn.IsOk());
		
		sorted_cfns.push_back(cfn);
	}
	
	// sort by # subdirs
	sort(sorted_cfns.begin(), sorted_cfns.end(), [](const wxFileName &cfn1, const wxFileName &cfn2)
		{	return (cfn1.GetDirCount() < cfn2.GetDirCount());
		});
	
	// convert to paths
	vector<wxString>	sorted_paths;
	
	for (auto cfn : sorted_cfns)	sorted_paths.push_back(cfn.GetPath());
	
	// prune non-ancestors
	for (int i = sorted_paths.size() - 1; i >= 1; --i)
	{	
		auto	me = sorted_paths[i];
		auto	prev = sorted_paths[i - 1];
		if (me.StartsWith(prev))
		{	// me is redundant
			sorted_paths.erase(sorted_paths.begin() + i);
			// restart
			i++;
		}
	}
}

//-----------------------------------------------------------------------------

	// lua root dir
	if (mis.ReadString() != "rel_dir")		return false;	// bad tag
	
	string	lua_root_rel_dir = mis.ReadString(); 			// CalcLuaRootRelDir().ToStdString();
	assert(!lua_root_rel_dir.empty());
	
	wxFileName	lua_cfn(lua_root_rel_dir, "");
	lua_cfn.MakeAbsolute(proj_cfn.GetPath());
	string	s = lua_cfn.GetFullPath();

//-----------------------------------------------------------------------------

static
wxBitmap	LoadCraw(const uint8_t *dataptr, const size_t &len, const wxBitmapType &typ)
{
	wxMemoryInputStream	mis(dataptr, len);
	assert(mis.IsOk());
	
	wxImage	img(mis, typ);
	assert(img.IsOk());
	
	wxBitmap	bm(img);
	assert(bm.IsOk());
	
	return bm;
}

#define	LOAD_CRAW(nm)	LoadCraw(nm##_craw.m_Data, nm##_craw.m_Len, (wxBitmapType) nm##_craw.m_Type)

//---- Lua Dir Drop Target ----------------------------------------------------


class LuaDirDropTarget : public wxFileDropTarget
{
public:
	LuaDirDropTarget(LuaDirCtrl *lua_dir, Controller *controller)
	{
		assert(lua_dir);
		assert(controller);
		
		m_LuaDir = lua_dir;
		m_Controller = controller;
	}
	
	virtual wxDragResult	OnDragOver(wxCoord x, wxCoord y, wxDragResult def)
	{
		assert(m_LuaDir);
		assert(m_Controller);
		
		if ((x == m_LastX) && (y == m_LastY))		return def;		// no pos change
		m_LastX = x; m_LastY = y;
		
		m_LuaDir->OnDragOver(wxPoint(x, y));
		
		return def;
	}
	
	virtual bool		OnDropFiles(wxCoord x, wxCoord y, const wxArrayString &filenames)
	{	
		// confirm where is dropped
		size_t		nFiles = filenames.GetCount();
		
		wxLogMessage("%ld files dropped", nFiles);
		return true;
	}
	
private:
	
	LuaDirCtrl	*m_LuaDir;		// owner
	Controller	*m_Controller;
	wxCoord		m_LastX, m_LastY;
};

//-----------------------------------------------------------------------------

// request dir listing
{	MemoryOutputStream 	mos;
	
	mos << CLIENT_MSG::REQUEST_DIR_LISTING << "~";
	
	ok = SendMessage(mos);
	assert(ok);
	
	wxLogMessage("  sent REQUEST_DIR_LISTING");
}

// get dir listing
{	vector<uint8_t>		msg_buff;
	
	ok = ReadMessage(msg_buff/*&*/);
	assert(ok);
	
	MemoryInputStream	mis(msg_buff);
	
	DAEMON_MSG	msg_t;
	
	mis >> msg_t;
	assert(DAEMON_MSG::REPLY_DIR_LISTING == msg_t);
	
	StringList	remote_dirs(mis);
	StringList	remote_files(mis);
	
	wxLogMessage("  received %lu remote dirs", remote_dirs.size());
	for (auto dir : remote_dirs)
	{
		wxLogMessage("    \"%s\"", dir);
	}
	
	wxLogMessage("  received %lu remote files", remote_files.size());
	for (auto dir : remote_dirs)
	{
		wxLogMessage("    \"%s\"", dir);
	}
	
}

// request file manifests
{	MemoryOutputStream 	mos;

	mos << CLIENT_MSG::REQUEST_FILE_MANIFESTS << manifests_request;

	ok = SendMessage(mos);
	assert(ok);
	
	wxLogMessage("  sent REQUEST_FILE_MANIFESTS");
}

// get file manifests
{	
	vector<uint8_t>		msg_buff;
	
	ok = ReadMessage(msg_buff/*&*/);
	assert(ok);
	
	MemoryInputStream	mis(msg_buff);
	
	DAEMON_MSG	msg_t;
	
	mis >> msg_t;
	assert(DAEMON_MSG::REPLY_FILE_MANIFESTS == msg_t);
	
	wxLogMessage("  received %s", MessageName(msg_t).c_str());
	
	const size_t	n_manifests = mis.Read32();
	
	for (int i = 0; i < n_manifests; i++)
	{
		FileManifest	fm(mis);
		
		daemon_manifests.push_back(fm);
		
		wxLogMessage("manifest %d", i);
		wxLogMessage("  fullname \"%s\"", fm.GetName().c_str());
		
		if (fm.HasProperties())
		{	wxLogMessage("  %lu bytes", fm.m_Size);
			wxLogMessage("  modified %s", fm.GetModifyStampString().c_str());
			wxLogMessage("  %lu source lines", fm.m_NumLines + 1);
			wxLogMessage("  md5 %s", fm.GetMD5().c_str());
		}
		else	wxLogMessage("  FILE MISSING");
		
		wxLogMessage("");
	}
}

// SYNC daemon files
{
	MemoryOutputStream	mos;
	
	mos << CLIENT_MSG::NOTIFY_BUNDLE_SYNC;
	
	// RANDOM destination path
	const wxString	daemon_path = wxString::Format("~/ddt_test%08x", rand());
	mos << daemon_path.ToStdString();
	
	m_TopFrame->GetSerializedSources(mos/*&*/);
	
	ok = m_ClientTCP->WriteMessage(mos);
	assert(ok);
}

// start lua
{	RequestStartupLua	req_startup(daemon_dir, "ddt_demo.lua", "main");
	
	MemoryOutputStream	mos;
	
	mos << CLIENT_MSG::NOTIFY_STARTUP_LUA << req_startup;
	
	ok = SendMessage(mos);
	assert(ok);
}

//-----------------------------------------------------------------------------

// request dir listing
{	MemoryOutputStream 	mos;
	
	mos << CLIENT_MSG::REQUEST_DIR_LISTING << "~";
	
	ok = SendMessage(mos);
	assert(ok);
	
	wxLogMessage("  sent REQUEST_DIR_LISTING");
}

//-----------------------------------------------------------------------------

// get dir listing
{	vector<uint8_t>		msg_buff;
	
	ok = ReadMessage(msg_buff/*&*/);
	assert(ok);
	
	MemoryInputStream	mis(msg_buff);
	
	DAEMON_MSG	msg_t;
	
	mis >> msg_t;
	assert(DAEMON_MSG::REPLY_DIR_LISTING == msg_t);
	
	StringList	remote_dirs(mis);
	StringList	remote_files(mis);
	
	wxLogMessage("  received %lu remote dirs", remote_dirs.size());
	for (auto dir : remote_dirs)
	{
		wxLogMessage("    \"%s\"", dir);
	}
	
	wxLogMessage("  received %lu remote files", remote_files.size());
	for (auto dir : remote_dirs)
	{
		wxLogMessage("    \"%s\"", dir);
	}
}

//---- Find Path Item ---------------------------------------------------------	

wxTreeItemId	LocalDirCtrl::FindPathItem(const wxString path)
	
	// WAS copied from wxGenericDirCtrl::ExpandPath() but hashsets work better?

{	bool		done_f = false;
	wxTreeItemId	tree_id = FindChild(GetRootId(), path, done_f/*&*/);
	
	// last non-zero tree id while dives deeper
	wxTreeItemId	last_id = tree_id;
	
	while (tree_id.IsOk() && !done_f)
	{
		tree_id = FindChild(tree_id, path, done_f/*&*/);
		if (tree_id.IsOk())	last_id = tree_id;
	}
	
	if (!last_id.IsOk())		return NULL_TREE_ITEM_ID;	// should never happen?

	wxDirItemData	*data = (wxDirItemData*) m_TreeCtrl->GetItemData(last_id);
	assert(data);
	
	return last_id;
}

//---- Setup Sections OVERLOAD ------------------------------------------------
	
	// overload so can veto default sections
void	LocalDirCtrl::SetupSections()
{
	// default
	AddSection("/", "HDD", wxFileIconsTable::drive);
}

//---- Expand Path ------------------------------------------------------------

void	LocalDirCtrl::ExpandPath(const wxString &path)
{
	wxLogMessage("LocalDirCtrl::ExpandPath(\"%s\")", path);
	
	wxFileName	cfn(path);
	assert(cfn.IsOk());
	
	wxArrayString	path_list = cfn.GetDirs();
	
	wxString	sep = wxFileName::GetPathSeparator();
	wxString	cummul_path = sep;
	
	for (auto dir : path_list)
	{
		cummul_path += dir + sep;
		
		m_ExpandedPathSet.insert(cummul_path.ToStdString());
	}
	
	m_CurrentPath = cummul_path;
	
	wxLogMessage("  cummul_path \"%s\"", cummul_path);
	
	// CallAfter(&LocalDirCtrl::Redraw);
}

//-----------------------------------------------------------------------------

	m_ExpandedPathSet.insert( {"/", "/home", "/home/plaufenb", "/home/plaufenb/Desktop"});
	DumpExpanded();
	
	CollapseAll();
	wxLogMessage("*** COMPOSITE ***");
	ExpandPath("/home/plaufenb/Desktop/");
	DumpExpanded();

//-----------------------------------------------------------------------------

	#define	wxUSE_DIRDLG	1			// wxWidgets HACKERY
	#include "wx/generic/dirctrlg.h"

//-----------------------------------------------------------------------------

bool	LocalDirCtrl::GetBoundingRect(const wxTreeItemId &item, wxRect &rc, bool text_only_f) const
{
	// GetSelections
	
	if (item == m_SelectedId)
	{	bool	f = wxTreeCtrl::GetBoundingRect(item, rc, text_only_f);
		
		rc.SetRight(GetClientSize().GetWidth());
		
		return f;
	}
	else	return wxTreeCtrl::GetBoundingRect(item, rc, text_only_f);
}

//-----------------------------------------------------------------------------

wxColour	LocalDirCtrl::GetItemBackgroundColour(const wxTreeItemId &item) const
{	
	// don't know the item ahead, since deletes all first
	const string	tagged_s = GetItemPath(item);
	
	bool	f = (tagged_s == m_CurrentPath);
	
	wxLogMessage("GetItemBackgroundColour(%s)", f ? "true" : "false");
	
	return f ? wxColour(255, 0, 0) : wxColour(255, 255, 255);
}

//-----------------------------------------------------------------------------

	SetItemTextColour(item, wxColour(0xFF, 0, 0));

//---- Do Color Path ----------------------------------------------------------

void	LocalDirCtrl::DoColorPath(void)
{
	wxLogMessage("LocalDirCtrl::DoColorPath(\"%s\")", wxString(m_CurrentPath));
	
	for (auto it : m_ItemIdToPathMap)
	{
		const string	path = it.second;
		wxTreeItemId	id = GetPathItem(path);
		
		if (path != m_CurrentPath)
			SetItemBackgroundColour(id, wxColour(0xff, 0xff, 0xff));	// normal
		else	SetItemBackgroundColour(id, wxColour(0xff, 0, 0));		// TAGGED
	}
}

//-----------------------------------------------------------------------------

// static
bool	Dir::IsDir(const string &path)
{
	return (path.back() == FileName::PATH_SEPARATOR_CHAR);
}

// static
bool	Dir::IsFile(const string &path)
{
	return !IsDir(path);
}

// static
string	Dir::TrimTrailingSep(const string &path)
{
	assert(path.back() == FileName::PATH_SEPARATOR_CHAR);
	
	return string(path, 0, path.size() - 1);
}

//-----------------------------------------------------------------------------

	// files
	for (auto fn : file_list)
	{
		wxTreeItemId	new_item_id = AppendItem(base_item, fn, TreeCtrlIcon_File, TreeCtrlIcon_FileSelected);
		
		string	path = base_path + fn;
		
		m_PathToItemIdMap.insert( {path, new_item_id} );
		m_ItemIdToPathMap.insert( {new_item_id, path} );
	}

//---- Render Recursive -------------------------------------------------------

void	LocalDirCtrl::RenderRecursive(const wxTreeItemId &base_item, string base_path, const int &depth)
{
	// wxLogMessage("LocalDirCtrl::RenderRecursive(\"%s\", depth %d)", wxString(base_path), depth);
	
	LX::Dir		cdir(base_path, m_ExpandedPathSet);
	StringList	dir_list = cdir.GetDirs();
	
	if (dir_list.empty())
	{	// (happens also when can't access dir contents)
		SetItemHasChildren(base_item, false);
	}
	else
	{	// ensure trailing separator
		if (base_path.back() != FileName::PATH_SEPARATOR_CHAR)		base_path += FileName::PATH_SEPARATOR_CHAR;
		
		// subdirs
		for (auto dir : dir_list)
		{
			wxTreeItemId	new_item_id = AppendItem(base_item, dir, TreeCtrlIcon_Folder, TreeCtrlIcon_FolderSelected);
			
			SetItemHasChildren(new_item_id, true);
		
			string	path = base_path + dir;
			
			m_PathToItemIdMap.insert( {path, new_item_id} );
			m_ItemIdToPathMap.insert( {new_item_id, path} );
		}
		
		Expand(base_item);
	}
}

//---- Dump Expanded paths ----------------------------------------------------

void	LocalDirCtrl::DumpExpandedPaths(void)
{
	wxLogMessage("LocalDirCtrl::DumpExpandedPaths()");
	
	vector<string>	expanded_list;
	
	for (auto path : m_ExpandedPathSet)		expanded_list.push_back(path);
	
	// sort
	sort(expanded_list.begin(), expanded_list.end(), [](const string &s1, const string &s2) {return s1 < s2;});
	
	for (int i = 0; i < expanded_list.size(); i++)
	{
		wxLogMessage("  [%2d] \"%s\"", i, wxString(expanded_list[i]));
	}
}

//-----------------------------------------------------------------------------

	static bool		IsDir(const std::string &path);
	static bool		IsFile(const std::string &path);
	static bool		IsRoot(const std::string &path);
	static std::string	TrimTrailingSep(const std::string &path);
	
//---- On End Drag ------------------------------------------------------------

void	DirTreeCtrl::OnEndDrag(wxTreeEvent &e)
{
	wxLogMessage("%s::OnEndDrag()", ImpName());
}

//=== Flat File Sync ==========================================================

	FlatFileSync::FlatFileSync()
		: m_Fullname(string()), m_FlatSize(0)
{	
}
		
	FlatFileSync::FlatFileSync(const string &dest_dir, LX::DataInputStream &dis)
		: FlatFileSync(), m_Fullname(dis.ReadString()), m_FlatSize(dis.Read32())
{
	const string	full_path = dest_dir + FileName::PATH_SEPARATOR + m_Fullname;
	
	// delete any existing file
	if (FileName::FileExists(full_path))		assert(FileName::DeleteFile(full_path));
	
	const size_t	flat_sz = m_FlatSize;
	
	vector<uint8_t>	buff(flat_sz, 0);
	
	dis.ReadBuffer(&buff[0], flat_sz);
	
	ofstream	os(full_path, ios_base::binary | ios_base::trunc/*zero dest file*/);
	assert(os.good());
	
	FileOutputStream	fos(os);
	
	fos.WriteBuffer(&buff[0], flat_sz);
}
LX::DataOutputStream& operator<<(LX::DataOutputStream &dos, const FlatFileSync &flat_file_sync)
{
	dos << flat_file_sync.m_Fullname << (uint32_t) m_FlatSize;
	
}

//=== Request Bundle Sync =====================================================

	RequestBundleSync::RequestBundleSync(const std::vector<FileSync> &file_bundle)
		: m_DaemonDir(dir), m_FileNames(fn_list)
{
}

	RequestBundleSync::RequestBundleSync(DataInputStream &dis)
		: m_DaemonDir(dis.ReadString()), m_FileNames(dis)
{
}

DataOutputStream& operator<<(DataOutputStream &dos, const RequestBundleSync &req_bundle_sync)
{
	dos << (uint32_t) req_bundle_sync.m_FlatFileList.size();
	for (auto it : req_bundle_sync.m_FlatFileList)	dos << it;
	return dos;
}

//---- Mapping Panel ----------------------------------------------------------

class MappingsPanel: public wxPanel
{
public:
	// ctor
	MappingsPanel(MappingsFrame *parent, int id, TopFrame *tf, Controller *controller)
		: wxPanel(parent, id)
	{
		assert(parent);
		assert(tf);
		assert(controller);
	
		m_MappingsFrame = parent;
		m_ClientFrame = tf;
		m_Controller = controller;
		
		m_LocalDirCtrl = new LocalDirCtrl(this, CTRL_ID_CLIENT_DIR_CTRL, m_MappingsFrame, this);
		m_LuaDirCtrl = new LuaDirCtrl(this, CTRL_ID_LUA_DIR_TREE, m_MappingsFrame, this, controller);
		
		wxBoxSizer	*h_sizer = new wxBoxSizer(wxHORIZONTAL);
	
		h_sizer->Add(m_LocalDirCtrl, wxSizerFlags(1).Expand());
		h_sizer->Add(m_LuaDirCtrl, wxSizerFlags(1).Expand());
		
		wxBoxSizer	*top_sizer = new wxBoxSizer(wxVERTICAL);
		
		top_sizer->Add(h_sizer, wxSizerFlags(1).Expand().Border(wxALL, 4));
		
		SetSizer(top_sizer);
		
		// Redraw();
	}
	
	void	Redraw(void)
	{
		assert(m_LocalDirCtrl);
		assert(m_LuaDirCtrl);
		
		m_LocalDirCtrl->RequestRedraw();
		
		m_LuaDirCtrl->RequestRedraw(true/*reset selection*/);
	}
	
	void	SelectMappedPath(const wxString &path)
	{
		assert(m_LocalDirCtrl);
		
		m_LocalDirCtrl->HighlightPath(path);
	}
	
	
private:
	
	MappingsFrame		*m_MappingsFrame;
	TopFrame		*m_ClientFrame;
	Controller		*m_Controller;
	
	DirTreeCtrl		*m_LocalDirCtrl;
	LuaDirCtrl		*m_LuaDirCtrl;
	
	// DECLARE_EVENT_TABLE()
};

//---- On SetFocus event ------------------------------------------------------

void	RemoterFrame::OnChildFocusEvent(wxChildFocusEvent &e)
{
	assert(m_TopHSizer);
	e.Skip();
	
	wxWindow	*win = e.GetWindow();
	if (!win)	return;		// no child window
	
	const int	id = win->GetId();
	
	const int	panel_index = (id == CONTROL_ID_LOCAL_DIR) ? 0 : ((id == CONTROL_ID_REMOTE_TREE) ? 1 : -1);
	if (panel_index == -1)		return;		// not a top panel
	
	wxSizerItem	*focused_sizer = m_TopHSizer->GetItem(panel_index);
	assert(focused_sizer && focused_sizer->IsWindow());
	wxSizerItem	*unfocused_sizer = m_TopHSizer->GetItem(1 - panel_index);
	assert(unfocused_sizer && unfocused_sizer->IsWindow());
	
	wxWindow	*focused_win = focused_sizer->GetWindow();
	assert(focused_win);
	wxWindow	*unfocused_win = unfocused_sizer->GetWindow();
	assert(unfocused_win);
	
	// wxSYS_COLOUR_ACTIVEBORDER & wxSYS_COLOUR_HIGHLIGHT too light
	focused_win->SetOwnBackgroundColour(wxColour(0x80, 0x80, 0x80));
	unfocused_win->SetOwnBackgroundColour(wxSystemSettings::GetColour(wxSYS_COLOUR_WINDOW));
}

//-----------------------------------------------------------------------------

	// prevent focus events
	// wxEventBlocker	blocker(this, wxEVT_KILL_FOCUS);
	// blocker.Block(wxEVT_KILL_FOCUS);
	
//===== Local Dir Control =====================================================

class LocalDirCtrl: public DirTreeCtrl
{
public:
	// ctor
	LocalDirCtrl(wxWindow *parent, int id, wxFrame *parent_frame, DirTreeListener *dtl)
		: DirTreeCtrl(parent, id, parent_frame, dtl)
	{
	}
	
	// IMPLEMENTATIONS
	virtual bool	IsLocal(void) const
	{
		return true;
	}
	
	virtual bool	OnDeleteFile(const string &fullpath)
	{
		return FileName::DeleteFile(fullpath);
	}
	
	virtual bool	OnDirListing(void)
	{
		wxLogMessage("LocalDirCtrl::OnDirListing()");
		
		// (never returns root)
		LX::Dir		cdir("/", 0, m_ExpandedPathSet);
		
		m_DirList = cdir.GetDirs();
		assert(m_DirList.size() > 0);
		m_FileList = cdir.GetFiles();
	
		wxLogMessage("  got %lu dirs, %lu files", m_DirList.size(), m_FileList.size());	
		
		return true;
	}
	
	wxString	ImpName(void) const
	{
		return "LocalDirCtrl";
	}
	
	int	StatusIndex(void) const
	{
		return 0;
	}
};

======================================================================

//===== generic STRING NODE ===================================================

	StringNode::StringNode()
{
	m_Name.clear();
	m_Children.clear();
	m_Parent = nil;
}
	
	StringNode::StringNode(const string &v, StringNode *parent)
		: StringNode()
{	
	m_Name = { v };
	m_Parent = parent;
}

	StringNode::StringNode(const char *ascii_p, StringNode *parent)
		: StringNode()
{
	m_Name = { string(ascii_p) };
	m_Parent = parent;
}

	StringNode::StringNode(DataInputStream &dis, StringNode *parent)
		: StringNode()
{
	m_Name = { dis.ReadString() };
	m_Parent = parent;
	
	const uint32_t	n = dis.Read32();
	
	for (int i = 0; i < n; i++)
	{	m_Children.push_back(new StringNode(dis, this));
	}
}

//---- DTOR -------------------------------------------------------------------

	StringNode::~StringNode()
{
	// first, delete any children
	while (m_Children.size())
	{
		StringNode	*c = m_Children.back();
		assert(c);
		
		delete c;
	}
	
	// remove self from parent
	if (m_Parent)
	{
		// get my index in parent's children
		const int	index = m_Parent->GetChildIndex(m_Name);
		assert(index != -1);
		bool	ok = m_Parent->erase(index);
		assert(ok);
	}
}

string	StringNode::Name(void) const
{
	return m_Name;
}

void	StringNode::Rename(const string &new_name)
{
	assert(!new_name.empty());
	
	m_Name = new_name;
}

bool	StringNode::empty(void) const
{
	return m_Children.empty();
}

StringNode*	StringNode::GetParent(void) const
{
	return m_Parent;
}

size_t	StringNode::NumChildren(void) const
{
	return m_Children.size();
}

int	StringNode::GetChildIndex(const string &k) const
{
	assert(!k.empty());
	
	for (size_t i = 0; i < m_Children.size(); i++)
	{	if (m_Children[i]->m_Name == k)		return i;
	}
	
	return -1;	// not found
}

bool	StringNode::HasChild(const string &k) const
{
	assert(!k.empty());
	return (GetChildIndex(k) != -1);
}

StringNode*	StringNode::at(const size_t &index)
{
	assert(index < m_Children.size());
	
	return m_Children.at(index);
}

StringNode*	StringNode::at(const string &k)
{
	assert(!k.empty());
	
	const int	index = GetChildIndex(k);
	assert(index != -1);
	
	return m_Children.at(index);
}

StringNode*	StringNode::add(const string &k)
{
	assert(!k.empty());
	assert(!HasChild(k));
	
	m_Children.push_back(new StringNode(k, this));
	
	return m_Children.back();
}

bool	StringNode::erase(const size_t &index)
{
	assert(index < m_Children.size());
	
	size_t	bf = m_Children.size();
	
	m_Children.erase(m_Children.begin() + index);
	
	return (m_Children.size() == (bf -1));
}

bool	StringNode::erase(const string &k)
{	
	assert(!k.empty());
	const int	index = GetChildIndex(k);
	assert(index != -1);
	
	return erase(index);
}

DataOutputStream& operator<<(DataOutputStream &dos, const StringNode &string_node)
{
	dos << string_node.m_Name << (uint32_t) string_node.m_Children.size();
	
	for (const auto it : string_node.m_Children)	dos << it;
	
	return dos;
}

// FLAKY MEMORY MANAGEMENT - REMOVE ? FIXME
class StringNode
{
public:
	// ctors
	StringNode();
	explicit StringNode(const std::string &v, StringNode *parent = nil);
	explicit StringNode(const char *ascii_p, StringNode *parent = nil);
	StringNode(LX::DataInputStream &dis, StringNode *parent = nil);
	// dtor
	virtual ~StringNode();
	
	std::string	Name(void) const;
	void		Rename(const std::string &new_name);
	StringNode*	GetParent(void) const;
	size_t		NumChildren(void) const;
	bool		HasChild(const std::string &k) const;
	bool		empty(void) const;
	StringNode*	add(const std::string &k);
	StringNode*	at(const size_t &index);
	StringNode*	at(const std::string &k);
	bool		erase(const std::string &k);
	bool		erase(const size_t &index);
	int		GetChildIndex(const std::string &k) const;

// private:
	
	std::string			m_Name;
	std::vector<StringNode*>	m_Children;
	StringNode			*m_Parent;
};
LX::DataOutputStream& operator<<(LX::DataOutputStream &dos, const StringNode &string_node);

//---- Get Map List as StringNode ---------------------------------------------

StringNode*	Controller::GetMapListAsStringNode(void)				// redundant logic -- FIXME
{
	if (m_StringNodePtr)
	{
		delete m_StringNodePtr;
		m_StringNodePtr = nil;
	}
	
	m_StringNodePtr = new StringNode("root");
	
	for (auto it : m_DirMapList)
	{
		m_StringNodePtr->add(it.m_LuaMapName);
	}
	
	// DumpStringNodeRecursive(m_StringNodePtr);
		
	return m_StringNodePtr;
}

//---- Dump StringNode Recursive ----------------------------------------------

void	Controller::DumpStringNodeRecursive(StringNode *snp, int level)
{
	if (!snp)	snp = m_StringNodePtr;
	if (!snp)	return;		// should be error ?
	
	const wxString	pad_s(' ', level * 4);
	
	wxLogMessage("[%2d] %s%s", level, pad_s, wxString(snp->Name()));
	
	for (int i = 0; i < snp->NumChildren(); i++)
	{
		DumpStringNodeRecursive(snp->at(i), level + 1);
	}
}

//--------------------------------------------------------------------

	RE2::Options	literalOptions;
	literalOptions.set_literal(true);

	// disable regex on envelope
	const RE2	envelopeRE(envelope, literalOptions);
	assert(envelopeRE.ok());

	bool	ok = RE2::GlobalReplace(&s, envelopeRE, resolved);
	assert(ok);

//--------------------------------------------------------------------

	// request file manifests
	{	MemoryOutputStream 	mos;
	
		mos << CLIENT_MSG::REQUEST_FILE_MANIFESTS << manifests_request;
	
		ok = SendMessage(mos);
		assert(ok);
	}
	
	// get file manifests
	{	
		vector<uint8_t>		msg_buff;
		
		ok = ReadMessage(msg_buff/*&*/);
		assert(ok);
		
		MemoryInputStream	mis(msg_buff);
		
		DAEMON_MSG	msg_t;
		
		mis >> msg_t;
		assert(DAEMON_MSG::REPLY_FILE_MANIFESTS == msg_t);
		
		wxLogMessage("  received %s", MessageName(msg_t).c_str());
		
		const size_t	n_manifests = mis.Read32();
		
		for (int i = 0; i < n_manifests; i++)
		{
			FileManifest	fm(mis);
			
			daemon_manifests.push_back(fm);
			
			wxLogMessage("manifest %d", i);
			wxLogMessage("  fullname \"%s\"", fm.GetName().c_str());
			
			if (fm.HasProperties())
			{	wxLogMessage("  %lu bytes", fm.m_Size);
				wxLogMessage("  modified %s", fm.GetModifyStampString().c_str());
				wxLogMessage("  %lu source lines", fm.m_NumLines + 1);
				wxLogMessage("  md5 %s", fm.GetMD5().c_str());
			}
			else	wxLogMessage("  FILE MISSING");
			
			wxLogMessage("");
		}
	}
	
//=== FLAT FILE SYNC =====================================================

class FlatFileSync
{
public:
	// ctors
	FlatFileSync();
	FlatFileSync(const std::string &dest_dir, LX::DataInputStream &dis);
		
	std::string	m_Fullname;
	size_t		m_FlatSize;
	// data

};
LX::DataOutputStream& operator<<(LX::DataOutputStream &dos, const FlatFileSync &flat_file_sync);

//--------------------------------------------------------------------

	// DOESN'T WORK BECAUSE OF MASK?
	// create the list since vanilla CTOR leaves it invalid
	m_AuxBitmaps.Create(DDT_ICON_SIZE, DDT_ICON_SIZE, false/*mask*/, DBGF_ID_AUX_BITMAP_LAST);
	
	// kindof lame, can't assign at specific position
	m_AuxBitmaps.Replace(BITMAP_ID_RED_DOT, LOAD_CRAW(red_dot));
	m_AuxBitmaps.Replace(BITMAP_ID_PLUS, LOAD_CRAW(plus));
	m_AuxBitmaps.Replace(BITMAP_ID_MINUS, LOAD_CRAW(minus));

//--------------------------------------------------------------------

	EVT_NAVIGATION_KEY(					TopFrame::OnNavigationEvent)		// doesn't work

void	TopFrame::OnNavigationEvent(wxNavigationKeyEvent &e)
{
	e.Skip();
	
	// if (!e.IsFromTab() || !e.GetCurrentFocus())	return;
	
	wxWindow	*w = e.GetCurrentFocus();
	if (w)		return;
	assert(w);
	
	const int	id = w->GetId();
	
	if (id == COMBOBOX_ID_DAEMON_HOST_N_PORT)
	{
		wxLogMessage("TopFrame::OnNavigationEvent(COMBOBOX_ID_DAEMON_HOST_N_PORT)");
	}
	else if (id == COMBOBOX_ID_LUA_MAIN_SOURCE_N_FUNCTION)
	{
		wxLogMessage("TopFrame::OnNavigationEvent(COMBOBOX_ID_LUA_MAIN_SOURCE_N_FUNCTION)");
	}
	else	wxLogMessage("TopFrame::OnNavigationEvent(nfi)");
}

//--------------------------------------------------------------------

	static
	vector<string>	s_TestRE = {	"/",
					"/home",
					"/home/",
					"/home/plaufenb",
					"/home/plaufenb/",
					"/home/plaufenb/Desktop",
					"/home/plaufenb/Desktop/",
					"/home/plaufenb/Desktop/john_jobs.txt"
					
					};
	
	const RE2	re(LX::SUBDIR_RE);
	assert(re.ok());
	
	for (auto path : s_TestRE)
	{	
		wxLogMessage("path \"%s\"", path);
		
		vector<string>		subdir_list;
		
		re2::StringPiece	input(path);
		string			subdir;
		
		while (RE2::FindAndConsume(&input, re, &subdir))	subdir_list.push_back(subdir);
		
		for (auto subd : subdir_list)
		{
			wxLogMessage("  \"%s\"", subd);
		}
		
		wxLogMessage("");
	}

//--------------------------------------------------------------------

	static
	vector<string>	s_TestRE = {	"$HOME",
					"$HOME/Desktop",
					"$DEVELOPMENT",
					"~/",
					"$DEVELOPMENT/inhance_depot"
					
					};
	
	for (const auto path : s_TestRE)
	{
		string	s = FileName::Normalize(path);
	
		wxLogMessage(" \"%s\" -> \"%s\"", wxString(path), wxString(s));
	}

//---- filename has Lua extension ? into name/ext -------------------------------------------

bool	FileName::HasLuaExtension(const string &filename)
{
	const RE2	re(HAS_LUA_EXT_RE);
	assert(re.ok());
	
	string	ext;
	
	const bool	ok = RE2::FullMatch(filename, re, &ext);
	return ok;
}

//--------------------------------------------------------------------

	const std::string	LUA_STARTUP_RE = "^(.*/)?(.+\\.lua):(.+)(\\(\\))?$";
	const RE2	re(LUA_STARTUP_RE);
	assert(re.ok());
	
	static
	vector<string>	s_TestRE = {	"script.lua:main()",
					"script.lua:main",
					"/script.lua:main",
					"remote_dir/script.lua:main",
					"/remote_dir/script.lua:main",
					"$RND/script.lua:main",
					
					};
	
	for (const auto s : s_TestRE)
	{
		// split lua: dir / filename / function
		
		string	dir, lua_filename, lua_function;
		
		const bool	ok = RE2::FullMatch(s, re, &dir, &lua_filename, &lua_function);
		assert(ok);
	
		wxLogMessage(" \"%s\" -> dir \"%s\", filename \"%s\", function \"%s\"", wxString(s), wxString(dir), wxString(lua_filename), wxString(lua_function));
	}

//--------------------------------------------------------------------

	StringList	bookmarks;
	
	bool	ok = GetBookmarks(bookmarks/*&*/);
	if (ok && (bookmarks.size() > 0))
	{	
		/*
		m_BookmarkRootId = AppendItem(m_RootId, "Bookmarks", TreeCtrlIcon_Folder, TreeCtrlIcon_FolderSelected);
		m_PathToItemIdMap.insert( {bmk_name, m_BookmarkRootId} );
		m_ItemIdToPathMap.insert( {m_BookmarkRootId, bmk_name} );
		m_ItemIdToType.insert( {m_BookmarkRootId, TREE_ITEM_TYPE::BOOKMARK} );
		*/
		
		for (const string bmk_name : bookmarks)
		{	const wxTreeItemId	bmk_item = AppendItem(m_RootId, bmk_name, TreeCtrlIcon_Folder, TreeCtrlIcon_FolderSelected);
			
			m_PathToItemIdMap.insert( {bmk_name, bmk_item} );
			m_ItemIdToPathMap.insert( {bmk_item, bmk_name} );
			m_ItemIdToType.insert( {bmk_item, TREE_ITEM_TYPE::BOOKMARK} );
		}
	}
	
//---- On Double Click -----------------------------------------------

bool	LocalDirCtrl::OnDoubleClick(const string &path)
{
	const TREE_ITEM_TYPE	typ = GetPathType(path, true/*fatal*/);
	if (typ != TREE_ITEM_TYPE::BOOKMARK)		return false;		// not handled
	
	wxLogMessage("LocalDirCtrl::OnDoubleClick(%s) BOOKMARK", wxString(path));
	
	return true;
}

//--------------------------------------------------------------------

	// rebuild menu without duplicates
	for (int i = 0; i < m_MRUMenu->GetMenuItemCount(); i++);
	{
		wxMenuItem	*menu_item = m_MRUMenu->FindItemByPosition(i);
		assert(menu_item);
		
		const wxString	menu_name = menu_item->GetItemLabel();
		bmk_set.insert(menu_name);
	}

//---- Set Bookmarks (from UI prefs load) ----------------------------

void	LocalDirCtrl::SetBookmarks(const StringList &bookmarks)
{
	StringList	sym_env_vars = { "$HOME", "$DEVELOPMENT", "$P4_WORKSPACE" };
	
	m_Bookmarks = FileName::Normalize(sym_env_vars);
	
	// wxLogMessage("SetBookmarks() = \"%s\"", m_Bookmarks.ToFlatString());
	
	m_ColorMap.clear();
	
	// set bookmark colors
	const wxColour	clr = wxColour(0, 120, 0);
	
	for (const auto path : m_Bookmarks)
	{
		m_ColorMap[path] = clr;
	}
}

//--------------------------------------------------------------------

	StringList	sym_env_vars = { "$HOME", "$DEVELOPMENT", "$P4_WORKSPACE" };
	
	sym_env_vars = FileName::Normalize(sym_env_vars);
	
	for (const auto bmk : sym_env_vars)
	{
		UpdateLocalMRU(bmk);
	}

//--------------------------------------------------------------------

	wxURI	uri(cfn.GetFullPath(wxPATH_NATIVE));
	// has no check ?

	const wxString	uri_s = uri.BuildURI();

//---- Add To Log View ------------------------------------------------------------------------

void	AddToLogView(const char *ln)
{
	printf("AddToLogView(\"%s\")\n", ln);
	
	UILabel	*log = s_TheViewController.m_LogView;
	
	// concat strings
	NSString	*s1 = log.text;
	NSString	*s2 = [NSString stringWithUTF8String:ln];
	
	s1 = [s1 stringByAppendingString:s2];
	s1 = [s1 stringByAppendingString:@"\n"];
	
	s_TheViewController.m_LogView.text = s1;
	
//	[s_TheViewController.m_LogView performSelectorOnMainThread:@selector(setText:) withObject:s1 waitUntilDone:YES];
//	[s_TheViewController.m_LogView setNeedsDisplay];
//	[s_TheViewController.m_LogView setNeedsLayout];

	// dispatch_main();
	
	// refresh UI
	[s_TheViewController TickIOS];
	
	// dispatch_async(dispatch_get_main_queue(), ^{});
}

//---- Get File HANDLE ---------------------------------------------------------

static
cHandle&&	GetFileHandle(const std::string &fullpath, const bool write_f = false)
{
	HANDLE	hFile = CreateFileA(	fullpath.c_str(),
					write_f ? FILE_GENERIC_WRITE : FILE_GENERIC_READ,
					0,							// share mode
					NULL,							// security attributes
					write_f ? CREATE_ALWAYS : OPEN_EXISTING,		// dwCreationDisposition
					FILE_ATTRIBUTE_NORMAL,					// dwFlagsAndAttributes
					NULL);							// hTemplateFile
	if (INVALID_HANDLE_VALUE == hFile)
	{
		// GetLastError()
		return cHandle();
	}

	return cHandle(hFile);
}

//------------------------------------------------------------------------------

DWORD
		WINAPI
		GetFileType(
		_In_ HANDLE hFile
		);

	struct stat	f_stat;
	
	const int	res = stat(fullpath.c_str(), &f_stat);
	if (res == -1)					return false;
	
	#ifdef WIN32
		m_ModifyStamp = f_stat.st_mtime;
	#else
		// get modify stamp -- haphazard struct
		m_ModifyStamp = (uint32_t) f_stat.st_mtim.tv_sec;	// (time_t)
	#endif

	// get size
	m_Size = (size_t) f_stat.st_size;

//------------------------------------------------------------------------------

	// convert to widechar string
	std::wstring	sw(path.begin(), path.end());
	
	const BOOL	ok = RemoveDirectory(sw.c_str());

//------------------------------------------------------------------------------

	_stat64		flags;

	const int	res = _stat64(path.c_str(), &flags);
	if (res != 0)	return false;

	// int	_fstat32(_In_ int _FileDes, _Out_ struct _stat32 * _Stat);
	// int	_stat32(_In_z_ const char * _Name, _Out_ struct _stat32 * _Stat);

//---- On Project File Mappings -----------------------------------------------

void	TopFrame::OnProjectFileMappings(wxCommandEvent &e)
{
	assert(m_MappingsFrame);
	
	wxLogMessage("OnProjectFileMappings");
	
	m_MappingsFrame->Raise();
	
	wxUpdateUIEvent	refresh_e(BROADCAST_ID_PROJECT_REFRESH);
	wxQueueEvent(m_MappingsFrame, refresh_e.Clone());
}

//------------------------------------------------------------------------------
	
// used on (a billion versions of) stat() on Windows
#define _S_IFMT         0xF000          /* file type mask */
#define _S_IFDIR        0x4000          /* directory */
#define _S_IFCHR        0x2000          /* character special */
#define _S_IFIFO        0x1000          /* pipe */
#define _S_IFREG        0x8000          /* regular */
#define _S_IREAD        0x0100          /* read permission, owner */
#define _S_IWRITE       0x0080          /* write permission, owner */
#define _S_IEXEC        0x0040          /* execute/search permission, owner */

//---- Split fullpath into dir/name/ext ---------------------------------------

bool	FileName::SplitFullPath(const string &fullpath, string &dir, string &name, string &ext)
{
	dir.clear();
	name.clear();
	ext.clear();
	if (fullpath.empty())		return false;

	const bool	ok = RE2::FullMatch(fullpath, SPLIT_VOL_DIR_FILE_EXT_RE, nil, &dir, &name, &ext);
	return ok;
}

//------------------------------------------------------------------------------

#ifdef __APPLE__
// doesn't work!
	#include "Foundation/NSFileManager.h"
	#include "Foundation/NSPathUtilities.h"
	#include "Foundation/NSString.h"
	#include "Foundation/NSPathUtilities.h"

#endif

//------------------------------------------------------------------------------

	// convert back to Windows path
	m_ExpandedDirSet.clear();
	for (const auto expanded_dir : m_ExpandedDirSet)
	{
		const string	win_path = FileName::ToLower(FileName::UnixToWinPath(expanded_dir));

		m_ExpandedDirSet.insert(win_path);
	}
	
//------------------------------------------------------------------------------

	// SUPER-RARE error without double parentheses - properly reported only by Clang
	wxFileName	cfn((wxString(path)));
			
//---- On Open Project menu event ---------------------------------------------

void	TopFrame::OnOpenProject(wxCommandEvent &e)
{
	assert(m_ProjectPrefs);
	
	wxString	new_projpath = ::wxFileSelector(	"Open Project", ""/*dir*/, ""/*name*/, "ddt",
								"ddt files (*.ddt)|*.ddt|All files (*.*)|*.*",
								wxFD_OPEN | wxFD_FILE_MUST_EXIST,
								this);
	if (new_projpath.IsEmpty())	return;
	
	bool	ok = m_ProjectPrefs->LoadProject(new_projpath);
	assert(ok);
}

//------------------------------------------------------------------------------

static
wxBitmap	LoadCraw(const uint8_t *dataptr, const size_t &len, const wxBitmapType &typ)
{
	wxMemoryInputStream	mis(dataptr, len);
	assert(mis.IsOk());
	
	wxImage	img(mis, typ);
	assert(img.IsOk());
	
	wxBitmap	bm(img);
	assert(bm.IsOk());
	
	return bm;
}

#define	LOAD_CRAW(nm)	LoadCraw(nm##_craw.m_Data, nm##_craw.m_Len, (wxBitmapType) nm##_craw.m_Type)

//---- Get ExpandedSet for this parent RECURSIVE ------------------------------

void	DirTreeCtrl::GetExpandedSet_Recurse(const wxTreeItemId &parent_item)
{
	// wxTreeItemIdValue	cookie;
	// wxTreeItemId		item = GetFirstChild(parent_item, cookie/*&*/);
	
	wxTreeItemId	item = parent_item;

	for (int i = 0; 0/*item.IsOk()*/; i++)
	{	if (!item.IsOk())	break;
		
		string	path = GetItemPath(item);
	
		wxLogUser1(" [%03d] \"%s\"", i, wxString(path));
		
		// item = GetNextVisible(item);
	}
	// GetNextChild(item, cookie
}

//---- On Mouse Left-Click ----------------------------------------------------

void	DirTreeCtrl::OnMouseLeftClick(wxMouseEvent &e)
{
	wxLogMessage("%s::OnMouseLeftClick()", ImpName());
	
	// always let focus run its course
	e.Skip();
	
	#if 0
	int			flags = 0;
	const wxTreeItemId	item = HitTest(e.GetPosition(), flags/*&*/);
	if (!item.IsOk() || !(flags & wxTREE_HITTEST_ONITEMBUTTON))		return;
	
	// clicked on triangle
	const string		path = GetItemPath(item);
	
	wxLogError("  clicked 'twist' triangle, path \"%s\"", wxString(path));
	
	ToggleBranch(item);
	
	RequestRedraw();
	#endif
}

//------------------------------------------------------------------------------

	// custom open/closed toggles
	m_ExpandedStateImageList = new wxImageList(DDT_ICON_SIZE, DDT_ICON_SIZE);
	m_ExpandedStateImageList->Add(LOAD_CRAW(arrow_right));				// not selected, not expanded
	m_ExpandedStateImageList->Add(LOAD_CRAW(arrow_right));				//     selected, not expanded
	m_ExpandedStateImageList->Add(LOAD_CRAW(arrow_down));				// not selected,     expanded
	m_ExpandedStateImageList->Add(LOAD_CRAW(arrow_down));				//     selected,     expanded
	SetStateImageList(m_ExpandedStateImageList);

//------------------------------------------------------------------------------

	// calc md5 hash & count line#s (Windows & not)
	// - avoid platform-dependent EOL handling, would corrupt MD5
	// - Stroustrup writes "binary I/O is system specific" @ chapter 38.2.1 (bullshit)
	// - no special handling of 1st lua script line (could be she-bang, but don't care)
	ifstream	ifs(fullpath.c_str(), ios_base::binary);
	if (ifs.fail() || ifs.bad())			return false;		// couldn't open
	
	uint8_t		buff[FileName::GetFileIOBufferSize()];
	MD5		hasher;
	HL_MD5_CTX	context;
	
	hasher.MD5Init(&context);
	
	int	nLF = 0, nCR = 0;
	
	while (!ifs.eof())
	{	
		const size_t	read_sz = ifs.read((char*)&buff[0], sizeof(buff)).gcount();
		if (!ifs.eof() && ifs.fail())		return false;		// read error
		
		// update EOL count
		for (int i = 0; i < read_sz; i++)
		{	nLF += (0x0a == buff[i]);
			nCR += (0x0d == buff[i]);	// (counted but not used)
		}
		
		// update hash
		hasher.MD5Update(&context, &buff[0], read_sz);
	}
	
	// store #lines
	m_NumLines = nLF;
	
	// finalize hash
	unsigned char digest[FileName::MD5_BINARY_SIZE];
	
	hasher.MD5Final(digest, &context);
	
	// convert binary digest to lowercase hex string (dunno why format gets reset)
	ostringstream	md5_stream;
	
	for (int i = 0; i < sizeof(digest); i++)
		md5_stream << hex << setfill('0') << setw(2) << (int) digest[i];
	
//------------------------------------------------------------------------------

	cfn.GetHumanReadableSize()
	
//------------------------------------------------------------------------------

	ENTRY(NAV_ID_GLOBE,	"earth.png",		"Globe")
	ENTRY(NAV_ID_BACK,	"back.png",		"Back")
	ENTRY(NAV_ID_UP,	"up.png",		"Up")
	ENTRY(NAV_ID_FORWARD,	"forward.png",	"Forward")
	ENTRY(NAV_ID_COPY,	"copy.png",		"Copy")
	ENTRY(NAV_ID_SYNC,	"sync.png",		"Sync")
	ENTRY(NAV_ID_OK,	"ok.png",		"OK")
	ENTRY(NAV_ID_EXIT,	"exit.png",		"Exit")


//---- Get Icons Path ---------------------------------------------------------

wxString	TopFrame::GetIconsPath(const wxString &subdir) const
{
	wxLogMessage("looking for IconsPath(\"%s\")", subdir);
	
	wxFileName	cfn(m_InitWorkingDir, "");
	assert(cfn.IsOk() && cfn.DirExists());
	
	if (cfn.GetDirs().back() != "Client")
	{	// fudge
		cfn.AppendDir("Client");
		assert(cfn.IsOk() && cfn.DirExists());
	}

	cfn.AppendDir("res");
	assert(cfn.IsOk() && cfn.DirExists());
	
	if (!subdir.empty())
	{
		cfn.AppendDir(subdir);
		assert(cfn.IsOk() && cfn.DirExists());
	}
	
	return cfn.GetPath(true/*with sep*/);
}

//---- Convert LuaMap-space to Client-space full path -------------------------

wxString	Controller::MappedFileToClientFullPath(const wxString &lua_fullpath) const
{
	assert(!lua_fullpath.empty());
	
	wxFileName	l_cfn(lua_fullpath);
	assert(l_cfn.IsOk());
	
	// get last dir name, will also prevent subdirs			tortuous - FIXME
	const wxString	map_name = l_cfn.GetDirs().Last();
	assert(!map_name.empty());
	
	const wxString	fname = l_cfn.GetFullName();
	assert(!fname.empty());
	
	DirMap	dm = GetMapFromMapName(map_name);
	assert(dm.IsOk());
	
	wxFileName	c_cfn(dm.GetClientDir(), fname);
	assert(c_cfn.IsOk() && c_cfn.FileExists());
	
	return c_cfn.GetFullPath();
}

virtual bool	OnDeleteFiles(const StringList &mapped_paths)
{
	assert(m_Controller);
	
	const wxString	short_name = m_Controller->MappedFileToClientShortName(wxString(mapped_paths.front()));
	assert(!short_name.empty());
		
	SourceFileClass	*sfc = m_Controller->GetSFC(short_name);
	assert(sfc);
	
	sfc->Destroy();
	
	return true;
}
	
//------------------------------------------------------------------------------

	asio::steady_timer	t(m_IOService, chrono::milliseconds());
	t.wait();

//---- Scroll to End ----------------------------------------------------------
	
void	OutputTextCtrl::ScrollToEnd(void)
{
	#ifdef __WIN32__
		// windows-only? (doesn't work with RichEdit 2.0 - using RichEdit 1.0 here!)
		ShowNativeCaret(true);
	#else
		ShowPosition(0x7FFFFFFF);		// looks very costly in Win32 implementation
	#endif
}

//---- On Update Frame Title event --------------------------------------------

void	TopFrame::OnUpdateFrameTitle(wxCommandEvent &e)
{
	assert(m_ProjectPrefs);
	
	const wxString	frame_title = TOP_FRAME_TITLE + " - \"" + m_ProjectPrefs->GetProjectName() + "\"" + (m_ProjectPrefs->IsDirty() ? "*" : "");
	
	SetTitle(frame_title);
	
	UpdateToolbarState();
}

//--------------------------------------------------------------------

	#if 0
	
		string	sym = "~/ddt_testd0a16c12/";
		
		wxLogMessage("sym = \"%s\"", wxString(sym));
		
		string	resolv = FileName::Normalize(sym);
		
		wxLogMessage("resolv = \"%s\"", wxString(resolv));
	#endif
	
	#if 0
		const int	n_items = 2500000;
		
		vector<string>	items;
		
		wxLogMessage("generating %d strings", n_items);
		
		for (int i = 0; i < n_items; i++)
			items.push_back(string(FileName::ByteListToHexString(FileName::GetRandomList(8/*bytes*/))));
		
		wxLogMessage("generating strings done, now sorting");
		
		wxStopWatch	sw;
		
		std::sort(items.begin(), items.end(), [&](const string &s1, const string &s2){return (s1 < s2);});
		
		wxLogMessage("sorting %d strings took %d ms", n_items, (int) sw.Time());
	#endif

	#if 0
		string	win = "C:\\Users\\Peter\\caca.log";
	
		bool	f = FileName::IsWinPath(win);
		
		string	unx = FileName::WinToUnixPath(win);
		
		f = FileName::IsWinPath(unx);
		
		string	win2 = FileName::UnixToWinPath(unx);
		
		f = FileName::IsWinPath(win2);
		
		f = !f;
	#endif

	#if 0
		// const RE2	re(R"___(^(?i)([c-z]:)?(.*)\\(.*)\.(.{3})$)___");
		bool	ok = re.ok();

		string	vol, dir, name, ext;

		// ok = RE2::FullMatch("C:\\development\\DDT3\\lua\\ddt_sub_file.lua", R"___(^(?i)([c-z]:)?(.*)\\(.*)\.(.{3})$)___", &vol, &dir, &name, &ext);
		// ok = RE2::FullMatch(string("\\development\\DDT3\\lua\\ddt_sub_file.lua"), R"___(^(?i)([c-z]:)?(.*)\\(.*)\.(.{3})$)___", &vol, &dir, &name, &ext);
		
		wxLogMessage("extracted val \"%s\", dir \"%s\", name \"%s\", ext \"%s\"", vol.c_str(), dir.c_str(), name.c_str(), ext.c_str());
	#endif

	#if 0
		StringList	vols = FileName::GetVolumeList();

		for (const auto s : vols)
		{
			wxLogMessage("DOS volume \"%s\"", s.c_str());
		}
	#endif

	#if 0
		// doesn't work on Windows!
		string		nix_path = "%USERPROFILE%\\env.lua";
		string		win_path = FileName::ExpandEnvVars(nix_path);

		wxLogMessage("converted \"%s\" -> \"%s\"", wxString(nix_path), wxString(win_path));

	#endif

	#if 0
		const std::string		SPLIT_DIR_FILE_EXT2_RE	= "^(.*)/(.*)$";		// file "/mach_kernel" has no extension
	
		const RE2	re(SPLIT_DIR_FILE_EXT2_RE);
		assert(re.ok());
		
		static
		vector<string>	s_TestRE = {	"/mach_kernel",
						"/home/peter/user-config.jam",
						"/home/plaufenb/Desktop/CDJ2Midi related/traktor docs/DJ backup files/collection_bkp_bf_mecenas.nml"
						
						};
		
		for (const string fullpath : s_TestRE)
		{
			string	body, ext;
			
			bool	ok = RE2::FullMatch(fullpath, "(.+)\\.(.{2,5})$", &body, &ext);
			if (!ok)	body = fullpath;
			
			string	dir, name;
			
			ok = RE2::FullMatch(body, re, &dir, &name);
			assert(ok);
			
			wxLogMessage(" \"%s\" -> dir \"%s\", name \"%s\", ext \"%s\"", wxString(fullpath), wxString(dir), wxString(name), wxString(ext));
		}
	#endif

//--------------------------------------------------------------------

	if (clean_arobas_f)
	{	// make sure 1st char is '@' otherwise is not a file, but a string
		if (shortpath[0] != '@')
		{	wxLogError("ERROR - couldn't display a source file that's a string");
			wxLogError(">string \"%s\"", shortpath);
			return false;
		}
		else
		{	// remove '@'
			shortpath = shortpath.Mid(1);
		}
	}
	
//--------------------------------------------------------------------

	while (!IsClientActive())
	{	bool	ok = m_Client->ReadMessage(buff/*&*/);
		if (!ok)
		{	wxLogError("ReadMessage() FAILED in WaitMessageLoop(), aborting");
			break;
		}
		
		const DAEMON_MSG	msg_t = m_Client->GetDaemonMessageType(buff);
		
		ok = QueueMessage(buff, true/*immediate*/);
		assert(ok);
		
		if (msg_t == DAEMON_MSG::NOTIFY_USER_LOG_BATCH)
		{	// let UI get updated
			CallAfter(&TopFrame::WaitMessageLoop);
			return;
		}
	}

//--------------------------------------------------------------------

	while (!IsClientActive())
	{	
		// do NOT block while waiting for message
		vector<uint8_t>	buff;
	
		while (!m_Client->HasAsyncMessage(buff/*&*/))
		{
			wxYieldIfNeeded();
		}
		
		const DAEMON_MSG	msg_t = m_Client->GetDaemonMessageType(buff);
			
		ok = QueueMessage(buff, true/*immediate*/);
		assert(ok);
		
		UpdateToolbarState();
	}
	
	UpdateToolbarState();

//--------------------------------------------------------------------

	asio::async_read(m_Socket, asio::buffer(&m_AsyncHeader[0], 4),
		[this](std::error_code ec, size_t sz)
		{
			if (!ec && (sz == 4))
			{	
				const uint32_t	body_sz = (m_AsyncHeader[0] << 24) | (m_AsyncHeader[1] << 16) | (m_AsyncHeader[2] << 8) | (m_AsyncHeader[3]);
				
				ReadBodyAsync(body_sz);
			}
			else
			{	wxLogError("ReadAsyncMessage() FAILED");
			}
		});
	
	m_AsyncPendingFlag = true;
	
	/*
	const size_t	sz = m_IOService.run();
	m_AsyncPendingFlag = (sz > 0);
	*/
	
	wxLogMessage("ClientTCP::StartReadMessage_Async() END");
	// m_IOService.run_one();
	
//---- Read Body ASYNC --------------------------------------------------------

void	ClientTCP::ReadBodyAsync(const size_t &body_sz)
{
	assert(body_sz > 0);
	
	m_AsyncReadBuff.resize(body_sz, 0);
	m_AsyncBodySize = body_sz;
	
	asio::async_read(m_Socket, asio::buffer(m_AsyncReadBuff),
		[this](std::error_code ec, size_t sz)
		{
			if (!ec && (sz == m_AsyncBodySize))
			{
				m_AsyncReadSize = sz;
			}
			else
			{	wxLogError("ReadBodyAsync() FAILED");
			}
		});
		
	// m_IOService.run_one();
	// m_IOService.stop();
}

//---- Received Async Message ? -----------------------------------------------

bool	ClientTCP::ReceivedAsyncMessage(vector<uint8_t> &buff)
{
	if (!CheckConnection())		return false;
	if (0 == m_AsyncReadSize)	return false;		// not yet
	
	// wxLogMessage("ClientTCP::ReceivedAsyncMessage(%d), stopped=%s", (int)m_AsyncReadSize, m_IOService.stopped() ? "true" :"false");
	
	buff.clear();
	buff.insert(buff.begin(), m_AsyncReadBuff.begin(), m_AsyncReadBuff.end());
	
	m_AsyncPendingFlag = false;
	
	return true;
}

//=============================================================================

// abstract class	-- GET RID once SourceListCtrl is canned - FIXME
class SourceCodeCtrl_ABSTRACT
{
public:	
	// ctor
	SourceCodeCtrl_ABSTRACT(const wxString &fpath, TopNotebook *parent, SourceFileClass *sfc);
	// dtor
	virtual ~SourceCodeCtrl_ABSTRACT()	{}
	
	virtual void	ShowLine(int highlight_ln) = 0;
	virtual	void	RemoveHighlight(void) = 0;
	virtual	int	GetSelectedLine(void) = 0;
	virtual void	ClearAnnotations(void) = 0;
	virtual void	SetAnnotation(int ln, const wxString &annotation_s) = 0;
	virtual void	ReloadFile(const wxString &fpath) = 0;
	
	virtual	void	DoRefresh(void) = 0;
	virtual int	GetTotalLines(void) = 0;
	virtual wxWindow*	GetWin(void) = 0;

protected:

	TopNotebook		*m_TopNotebook;
	SourceFileClass		*m_OwnerSource;
};

//---- Set Local Lua Path --------------------------------------------

void	Controller::SetLocalLuaPath(const wxString lpath)
{
	wxFileName	cfn(m_LocalLuaPath, "");
	assert(cfn.IsOk() && cfn.DirExists());
	
	cfn.AppendDir(lpath);
	
	m_LocalLuaPath = cfn.GetPath();
}

virtual wxDragResult	OnDragOver(wxCoord x, wxCoord y, wxDragResult def)
{
	assert(m_TopNotebook);
	assert(m_Controller);

	if ((x == m_LastX) && (y == m_LastY))		return def;		// no pos change
	m_LastX = x; m_LastY = y;

	m_TopNotebook->OnDragOver(wxPoint(x, y));

	return def;
}

//---- On Drag Over -----------------------------------------------------------

void	TopNotebook::OnDragOver(const wxPoint pt)
{
	assert(m_TopFrame);
	
	const wxString	msg = wxString::Format("TopNotebook::OnDragOver(%d, %d)", pt.x, pt.y);
	
	m_TopFrame->SetStatusText(msg, 0);
}

//---- TopNotebook Drop Target ------------------------------------------------

class TopNotebookDropTarget : public wxFileDropTarget
{
public:
	TopNotebookDropTarget(Controller *controller)
	{
		assert(controller);

		m_Controller = controller;
	}
	
	// implementation
	virtual bool	OnDropFiles(wxCoord x, wxCoord y, const wxArrayString &filenames)
	{
		StringList	sl;

		for (int i = 0; i < filenames.GetCount(); i++)
			sl.push_back(filenames[i].ToStdString());
		
		bool	ok = m_Controller->OnDroppedFiles(sl);
		return ok;
	}
	
private:
	
	Controller	*m_Controller;
};

//---- On Mouse Move event ----------------------------------------------------

void	StyledSourceCtrl::OnMouseMove(wxMouseEvent &e)
{
	if (!e.ControlDown())		return;		// only on CONTROL down
	
	const wxPoint	pt = e.GetPosition();
	
	const int	index = PositionFromPointClose(pt.x, pt.y);
	if ((index == wxSTC_INVALID_POSITION) || (index == m_LastIndex))	return;
	
	m_LastIndex = index;
	
	if ((e.ControlDown()) && !CallTipActive() && !m_ToolTipTimer.IsRunning())
	{
		CallTipShow(index, "mouseover tooltip test");
		
		m_ToolTipTimer.StartOnce(5000);
	}
	
	const int	ln = LineFromPosition(index);
	const int	col = GetColumn(index);
	
	wxString	word, style_s;
	
	bool	ok = GetWordAndStyle(index, word/*&*/, style_s/*&*/);
	if (!ok)	return;
	
	const wxString	pad_s(' ', 20 - word.Len());

	wxLogGeneric(MOUSE_OVER_LOG, "word \"%s\"%s %s", word, pad_s, style_s);
}

//---- On Tooltip Timer lapsed ------------------------------------------------

void	StyledSourceCtrl::OnTootipTimer(wxTimerEvent &e)
{
	CallTipCancel();
}

//---- Get Source Lines -------------------------------------------------------

vector<wxString>	EditorCtrl::GetSourceLines(void) const
{
	const int	n_lines = GetNumberOfLines();
	
	vector<wxString>	lines;
	
	for (int i= 0; i < n_lines; i++)	lines.push_back(GetLineText(i));
	
	// m_DirtyFlag = false;		// should be EVENT
	
	return lines;
}

//---- Do Reload --------------------------------------------------------------

void	SourceFileClass::DoReload(void)
{
	// wxLogError("DoReload()");
	// assert(m_EditorCtrl);
	
	// m_EditorCtrl->ReloadFile(m_FullFilePath);
}

//---- On Text Modified (not necessarily dirty, could have undo) --------------

void	SourceFileClass::OnTextModified(void)
{
	assert(m_Controller);
	
}

//---- On Double-Clicked Line -------------------------------------------------

void	SourceFileClass::OnDoubleClickedLine(const int &ln)
{
	assert(m_Controller);
	
	m_Controller->OnEditFileAtLine(m_FullFilePath, ln);
}

//---- On Edit FILE:LINE ------------------------------------------------------

void	Controller::OnEditFileAtLine(const wxString &fullpath, const int &ln)
{
	assert(m_TopFrame);
	
	wxLogMessage("Controller::OnEditFileAtLine(\"%s\", %d)", fullpath, ln);
	
	bool	ok = m_TopFrame->OnEditLuaFileAtLine(fullpath.ToStdString(), ln);
	if (!ok)	wxLogError("  failed");
}

//---- Check Edited SFCs ------------------------------------------------------

bool	Controller::CheckEditedSFCs(void)
{
	vector<SourceFileClass*>	sfc_list = GetSFCInstances();
	
	bool	tot_edited_f = false;
	
	for (SourceFileClass *sfc : sfc_list)
	{	
		const string	fullpath = sfc->GetFullPath();
		assert(FileName::FileExists(fullpath));
		
		const string	old_md5 = sfc->GetProperties().m_MD5.ToStdString();
		const string	new_md5 = FileName::CalcFileMD5(fullpath);
		
		const bool	edited_f = (old_md5 != new_md5);
		
		tot_edited_f |= edited_f;
		
		if (edited_f)
		{	sfc->DoReload();
			
			sfc->GetProperties(true/*recalc*/);
		}
	}
	
	if (tot_edited_f)	SetDirtyProject();
	
	return tot_edited_f;
}

//---- On Save File Menu event ------------------------------------------------

void	EditorCtrl::OnSaveFileMenu(wxCommandEvent &e)
{
	assert(m_OwnerSFC);
	
	wxLogMessage("EditorCtrl::OnSaveFileMenu()");
	
	const int	n_lines = GetNumberOfLines();
	
	vector<wxString>	text_lines;
	
	for (int i= 0; i < n_lines; i++)	text_lines.push_back(GetLineText(i));
	
	m_OwnerSFC->DoSaveFile(text_lines);
	
	m_DirtyFlag = false;
}

//---- On Save File Menu event ------------------------------------------------

void	TopFrame::OnSaveFileMenu(wxCommandEvent &e)
{
	wxLogMessage("TopFrame::OnSaveFileMenu()");
	assert(m_TopNotebook);
	
	SourceFileClass	*sfc = m_TopNotebook->GetSelectedSFC();
	assert(sfc);	//		return;				// no selected top tab?
	
	bool	ok = sfc->DoSaveFile();
}

//---- Check Dirty SFC Editors ------------------------------------------------

bool	Controller::CheckDirtySFCEditors(void)
{
	vector<SourceFileClass*>	sfc_list = GetSFCInstances();
	
	bool	tot_edited_f = false;
	
	for (SourceFileClass *sfc : sfc_list)
	{	
		const string	fullpath = sfc->GetFullPath();
		assert(FileName::FileExists(fullpath));
		
		const bool	edited_f = sfc->IsEditorDirty();
		
		tot_edited_f |= edited_f;
		
		if (edited_f)
		{	// sfc->DoReload();
			
			sfc->GetProperties(true/*recalc*/);
		}
	}
	
	if (tot_edited_f)	SetDirtyProject();
	
	return tot_edited_f;
}

// void			OnEditFileAtLine(const wxString &fullpath, const int &ln);
// bool			CheckEditedSFCs(void);
bool			CheckDirtySFCEditors(void);

//---- Is Text Modified ? -----------------------------------------------------

bool	EditorCtrl::IsTextModified(void) const
{
	const bool	f = IsModified();
	
	return f;
}

//----- Reload Source File ----------------------------------------------------

void	EditorCtrl::ReloadFile(const wxString &fpath)
{
	SetReadOnly(false);
	
	bool	ok = LoadFile(fpath);
	assert(ok);
	
	Refresh();
	
	SetReadOnly(true);
	
	// SetTextRaw(const char* text)
}

bool	IsEditorDirty(void) const;

wxString			m_LuaEditorCommandString;

	{wxCMD_LINE_OPTION,	"e",	"edit",		"lua editor command",	wxCMD_LINE_VAL_STRING,		wxCMD_LINE_VAL_NONE	},

	ok = CmdLine.Found("e", &editor_cmd);
	if (!ok)
	{
		#ifdef WIN32
			// no default for Windows yet
		#else
			// Linux defauly uses Geany
			editor_cmd = "geany +__LINE__ __FILE__";
		#endif
	}
	
	if (!editor_cmd.empty())
	{
		ok = tf->SetEditorCommand(editor_cmd);
		if (!ok)	wxLogError("couldn't set editor command \"%s\"", editor_cmd);
	}

//---- Set Lua File Editor Command --------------------------------------------

bool	TopFrame::SetEditorCommand(const wxString &editor_cmd)
{
	assert(m_Controller);
	
	m_LuaEditorCommandString.clear();
	
	const size_t	ln_index = editor_cmd.find(DDT_EDITOR_LINE_TAG);
	if (ln_index == string::npos)
	{	wxLogError("EditorCommand string has no __LINE__ tag");
		return false;
	}
	
	const size_t	fn_index = editor_cmd.find(DDT_EDITOR_FILE_TAG);
	if (fn_index == string::npos)
	{	wxLogError("EditorCommand string has no __FILE__ tag");
		return false;
	}
	
	m_LuaEditorCommandString = editor_cmd;
	
	return true;
}

//---- Send File Bundle ----------------------------------------------

bool	Client::SendFileBundle(const wxString &remote_dir)
{
	wxLogMessage("Client::SendFileBundle(\"%s\")", remote_dir);
	assert(!remote_dir.empty());
	assert(m_ClientTCP && m_ClientTCP->IsConnected());
	
	MemoryOutputStream	mos;
	
	mos << CLIENT_MSG::PUSH_FILE_BUNDLE << remote_dir.ToStdString();
	
	GetSerializedSources(mos/*&*/);
	
	bool	ok = SendMessage(mos);
	
	return ok;
}

//---- On Tool Sync -----------------------------------------------------------

void	TopFrame::OnToolSync(wxCommandEvent &e)
{
	assert(m_Controller);
	assert(m_ToolBar);
	if (!m_ToolBar->GetToolEnabled(TOOL_ID_SYNC))	return;		// ignore (function keys are always wired)
	assert(m_Client && m_Client->IsConnected());
	
	assert((m_Controller->GetInitLevel() >= INIT_LEVEL::CONNECTED) && (m_Controller->GetInitLevel() <= INIT_LEVEL::SYNCED));
	
	bool	ok = GetStartupLuaStruct();
	if (!ok)
	{	// incomplete
		wxLogError("Startup field is INCOMPLETE");
		return;					
	}
	
	// resolve any $RND (can't resolve more on client)
	m_StartupLuaStruct.m_Dir = FileName::ResolveRandom(m_StartupLuaStruct.m_Dir);
	
	if (!CheckConnection())		return;
	ok = m_Client->SendFileBundle(m_StartupLuaStruct.m_Dir);
	if (!CheckConnection())		return;
	assert(ok);
	
	// wait for daemon confirmation
	WaitForNewMessage();
	// CallAfter(&TopFrame::WaitMessageLoop);
}

//---- On Edited File Timer ---------------------------------------------------

void	TopFrame::OnEditedFileTimer(wxTimerEvent &e)
{
	assert(m_Controller);
	
	// bool	change_f = m_Controller->CheckEditedSFCs();
	// if (change_f)	wxLogWarning("CHANGED FILE(S)");
	
	// UpdateThrobber();
}

	EVT_LEFT_DCLICK(						EditorCtrl::OnMouseLeftDoubleClick)
	EVT_STC_DOUBLECLICK(		wxID_ANY,			EditorCtrl::OnDoubleClickTextLine)		// crashes whole system!

//---- On Double Click (text) Line --------------------------------------------

	// crashes THE WHOLE FUCKING SYSTEM (i.e. Debian)

void	EditorCtrl::OnDoubleClickTextLine(wxStyledTextEvent &e)
{
	assert(m_OwnerSFC);
	
	// const int	ln = e.GetLine();
	
	// const int	ln = LineFromPosition(e.GetPosition());
	
	// m_OwnerSFC->OnDoubleClickedLine(ln + 1);
	
	e.Skip();
}

//---- On Mouse Left Double-Click ---------------------------------------------

void	EditorCtrl::OnMouseLeftDoubleClick(wxMouseEvent &e)
{
	assert(m_OwnerSFC);
	
	const int	ln = GetCurrentLine();
	
	m_OwnerSFC->OnDoubleClickedLine(ln + 1);
	
	// e.Skip();
}

----------------------------------------------------------------------
	
	// never called because intercepts mouse click
	EVT_NOTEBOOK_PAGE_CHANGED(	-1,				TopNotebook::OnNotePageChanged)

//---- On Notebook Page Changed -----------------------------------------------

void	TopNotebook::OnNotePageChanged(wxBookCtrlEvent &e)
{
	e.Skip();
	
	// const int	page = e.GetSelection();
	const int	page = GetSelection();
	
	wxLogMessage("OnNotePageChanged %d", page);
	
	if (wxNOT_FOUND == page)	return;		// ignore
	
	SourceFileClass	*sfc = GetNth(page);
	assert(sfc);
		
	sfc->RestoreCursorPos();
}

// m_ToolTipTimer.SetOwner(this, TIMER_ID_SFC_TOOLTIP_TIMER);
	
	// EVT_MOTION(							EditorCtrl::OnMouseMove)
	// EVT_TIMER(			TIMER_ID_SFC_TOOLTIP_TIMER,	EditorCtrl::OnTootipTimer)

//---- On SFC Editor Cursor Position Changed ----------------------------------

void	Controller::OnSFCEditorCursorPosChanged(SourceFileClass *sfc)
{
	assert(sfc);
	assert(m_EditorStatusBar);
	
	EditorCtrl	*ed = sfc->GetEditorCtrl();
	assert(ed);
	
	m_EditorStatusBar->UpdateStatus(ed);
}

	EVT_TOGGLEBUTTON(	BUTTON_ID_BASE + BTN_INDEX_HIGHLIGHT,				SearchBar::OnToggleHighlightButton)
// EVT_TOGGLEBUTTON(	-1,		SearchBar::OnToggleButton)
	
//---- On Toggle Highlight Button event ---------------------------------------

void	SearchBar::OnToggleHighlightButton(wxCommandEvent &e)
{
	assert(m_TopNotebook);
	
	const bool	f = e.IsChecked();
	wxLogMessage("Highlight %s", f ? "ON" : "off");
	
	SourceFileClass	*sfc = m_TopNotebook->GetSelectedSFC();
	if (sfc)
	{
		EditorCtrl	*styled_editor = sfc->GetEditorCtrl();
		assert(styled_editor);
		
		if (f)		styled_editor->HighlightSearchResults(m_HitList);
		else		styled_editor->RemoveSearchHighlights();
	}
}

//--------------------------------------------------------------------

	// DOESN'T WORK
	wxEventBlocker	block(this, wxEVT_SET_FOCUS);
	block.Block(wxEVT_KILL_FOCUS);
	block.Block(wxEVT_CHILD_FOCUS);
	
//---- Highlight Search Results -----------------------------------------------

void	EditorCtrl::HighlightSearchResults(const vector<SearchHit> &hit_list)
{
	SetIndicatorCurrent(SEARCH_INDICATOR_ID);
	// SetIndicatorValue(1);		// (ignored by Stc for now)
	
	// clear all first...
	IndicatorClearRange(0, GetLastPosition());
	
	// ...the enable ranges
	for (const SearchHit &hit : hit_list)
	{
		const int	pos1 = hit.m_Pos1;
		const int	pos2 = hit.m_Pos2;
		const int	len = (pos2 - pos1);
		
		IndicatorFillRange(pos1, len);
	}
}

//--------------------------------------------------------------------

	if (!wxGetCwd().IsSameAs(app_cfn.GetPath(), false/*no case*/))
	{	// work around LLDB bug
		pre_log << "CWD was ****** " << wxGetCwd() << "\n";
		wxSetWorkingDirectory(app_cfn.GetPath());
		pre_log << "CWD now " << wxGetCwd() << "\n";
	}

//---- dead-slow (non-cost) wxStc for styled text retrieval ----------

	wxMemoryBuffer buff = GetStyledText(pos, pos + 1);	// int startPos, int endPos);
	
	const size_t	sz = buff.GetDataLen();
	assert(sz > 0);
	
	uint8_t	*p = (uint8_t*) buff.GetData();
	assert(p);
	
	styl2 = p[1];

//--------------------------------------------------------------------

	// does NOT work
	bool	TopNotebookImp::AcceptsFocus() const
	{
		return false;
	}
	bool	TopNotebookImp::AcceptsFocusRecursively() const
	{
		return false;
	}

//---- Get Word and Style -----------------------------------------------------

bool	EditorCtrl::GetWordAndStyle(const int &index, wxString &word, wxString &style_s)
{
	const int	w_start = WordStartPosition(index, true/*only word chars*/);
	const int	w_end = WordEndPosition(index, true/*only word chars*/);
	
	// reset cache on inconclusive style
	if (GetStyleAt(w_start) == wxSTC_LUA_DEFAULT)
	{	m_LastWordStart = -1;
		return false;
	}
	
	if ((w_start == m_LastWordStart) || (w_start >= w_end))	return false;		// no change
	m_LastWordStart = w_start;
	
	uint32_t	style_mask = 0;
	
	for (int i = w_start; i < w_end; i++)
	{	word << (char) GetCharAt(i);
		
		const int	styl_ind = GetStyleAt(index);
		if ((styl_ind < 0) || (styl_ind >= 32))		continue;		// beyond lexer range
		
		style_mask |= (1L << styl_ind);
	}
	
	// count # styles
	int	n_styles = 0;
	
	for (int i = 0; i < 32; i++)	n_styles += (((style_mask & (1L << i)) != 0) ? 1 : 0);
	
	if (n_styles == 1)
	{	// word uses single style
		const int	single_style = GetStyleAt(w_start);
		if (single_style < s_LuaStyleLUT.size())
			style_s = s_LuaStyleLUT.at(single_style);			// get symbolic name
		else	style_s = wxString::Format("undefined%d", single_style);	// not defined in STC Lua lexer
	}
	else	style_s = wxString::Format("0x%08x", style_mask);			// zero or multiple styles
	
	return true;
}

//--------------------------------------------------------------------

	// doesn't return style
	wxCharBuffer	buff = GetLineRaw(ln);
	const size_t	buff_sz = buff.length();
	
//--------------------------------------------------------------------

	const uint8_t	r8 = rand() * 255ul / RAND_MAX;
	const uint8_t	g8 = rand() * 255ul / RAND_MAX;
	const uint8_t	b8 = rand() * 255ul / RAND_MAX;
	
	dc.SetBrush(wxBrush(wxColour(r8, g8, b8, 0xff), wxBRUSHSTYLE_SOLID));

//--------------------------------------------------------------------
			
	wxLogMessage("sync & startup succeeded");
	
	m_Controller->SetAllSFCEditLockFlag(true);
	
	m_StatusBar->SetForegroundColour(*wxBLACK);
	m_StatusBar->SetStatusText("", 0);
	
	m_Controller->SetInitLevel(INIT_LEVEL::LUA_STARTED);
	
	// hide setup frames
	m_MappingsFrame->Hide();
	#if DDT_SHOW_REMOTER_FRAME
		m_RemoterFrame->Hide();
	#endif

	WaitForNewMessage();				// CACA - DOESN'T send anything back ?

//---- Randomize --------------------------------------------------------------

void	MemoryViewCtrl::Randomize(void)
{
	const size_t	len = rand() * 1000ul / RAND_MAX;
	
	m_Buff.resize(len);
	
	for (int i = 0; i < len; i++)		m_Buff[i] = rand();
	
	RedrawMemory(n_cols);
}

//--------------------------------------------------------------------

	const int	tab = (-i % n_per_line);
	wxString	pad(' ', tab * 3);
	hd << pad << " | " << ascii << " | \n";

//---- Resolve Variable -------------------------------------------------------

const uint8_t *VarViewCtrl::ResolveVar(const string &k, size_t &sz)
{
	sz = 0;
	if (k.empty())		return nil;
	
	for (int i = 0; i < m_CollectedList.size(); i++)
	{
		const Collected	&ce = m_CollectedList[i];
		
		if (!ce.IsHugeString())	continue;
		if (ce.GetKey() != k)	continue;
		
		const std::string	&v = ce.GetVal();
		
		const uint8_t	*p = (const uint8_t*) v.data();
		assert(p);
		
		sz = v.length();
		
		return p;
	}
	
	return nil;		// not found
}

//---- Set Memory Variable buffer ---------------------------------------------

void	MemoryViewCtrl::SetMemVar(const string &k, const uint8_t *data, const size_t &len)
{
	assert(m_TextEditCtrl);
	assert(m_HexCtrl);
	assert(m_AsciiCtrl);
	assert(m_BottomNotebook);
	
	wxLogMessage("MemoryViewCtrl::SetMemVar(\"%s\") with %d bytes", wxString(k), (int)len);

	if (!data || (len == 0))
	{	m_Buff.clear();
		m_HexCtrl->Clear();
		// m_AsciiCtrl->Clear();
		return;
	}
	
	// copy to own buffer
	m_Buff.assign(&data[0], &data[len]);
	
	m_TextEditCtrl->SetValue(wxString(k));
	
	RedrawMemory();
	
	if (m_BottomNotebook->GetCurrentPage() != this)
		m_BottomNotebook->ChangeSelection(NOTEBOOK_PAGE_MEMORY);
}

//---- On Edit Lua File at Line -----------------------------------------------

bool	TopFrame::OnEditLuaFileAtLine(const string &fn, const int &ln)
{
	if (m_LuaEditorCommandString.empty())
	{	wxLogError("no editor was defined");
		return false;
	}
	
	string	cmd = m_LuaEditorCommandString.ToStdString();
	
	const size_t	ln_index = cmd.find(DDT_EDITOR_LINE_TAG);
	assert(ln_index != string::npos);
	
	cmd.replace(cmd.begin() + ln_index, cmd.begin() + ln_index + DDT_EDITOR_LINE_TAG.size(), to_string(ln));
	
	const size_t	fn_index = cmd.find(DDT_EDITOR_FILE_TAG);
	assert(fn_index != string::npos);
	
	cmd.replace(cmd.begin() + fn_index, cmd.begin() + fn_index + DDT_EDITOR_FILE_TAG.size(), string("'") + fn + string("'"));
	
	const long	pid = wxExecute(cmd, wxEXEC_ASYNC);
	return (pid != 0);
}

//--------------------------------------------------------------------

	size_t	sz = 0;
	
	const uint8_t	*p = m_LocalsVarViewCtrl->ResolveVar(m_MemoryWatch, sz/*&*/);
	if (!p)				return;		// not found
	
	m_MemoryViewCtrl->SetMemVar(m_MemoryWatch, p, sz);

//--------------------------------------------------------------------

	wxListItem	item;
	
	item.SetMask(wxLIST_MASK_IMAGE | wxLIST_MASK_TEXT);
	item.SetId(row);
	item.SetColumn(COLUMN_VAL_STR);
	item.SetImage(BITMAP_ID_PLUS);
	item.SetText(wxString::Format("[%zu chars]", str_sz));
	
	SetItem(item);

//--------------------------------------------------------------------

	const int	row = e.GetIndex();
	assert((row >= 0 ) && (row < m_Parent->m_CollectedList.size()));
	
	const Collected	&ce = m_Parent->m_CollectedList[row];
	
	if (!ce.IsTable())		return;
	
	wxMenu	menu("");
	
	menu.Append(CONTEXT_MENU_ID_VARVIEW_COLLAPSE_TABLE, "Collapse Table");
	
	// immediate popup menu -- will send FOCUS event
	const int	id = GetPopupMenuSelectionFromUser(menu);
	e.Skip();	// release mouse
	if (id < 0)			return;		// canceled
	
	if (id == CONTEXT_MENU_ID_VARVIEW_COLLAPSE_TABLE)
	{	// would have to remove all entries BELOW this path
		m_Parent->m_ExpandedTablesHashSet.erase(ce.m_Path);

		// refresh
		m_Parent->DoRefresh();
	}

//--------------------------------------------------------------------

	// never called
	EVT_STC_STYLENEEDED(		-1,					EditorCtrl::OnStyleNeededEvent)

//---- Get Lexer Style at Pos -------------------------------------------------

void	EditorCtrl::OnStyleNeededEvent(wxStyledTextEvent &e)
{
	assert(m_OwnerSFC);
	
	wxLogWarning("OnStyleNeededEvent(%d)", (int)e.GetPosition());
	
	e.Skip();
}

//---- On Menu Item Highlighted event -----------------------------------------

void	TopFrame::OnMenuItemHighlighted(wxMenuEvent &e)
{
	e.Skip();
	
	// ignore popup menus
	if (e.IsPopup())
	{
		m_HighlitMenuID = 0;
		return;
	}
	
	const int	id = e.GetMenuId();
	
	if (id != m_HighlitMenuID)
	{
		wxLogMessage("highlit menu changed to %d", id);
		
		m_HighlitMenuID = id;
		m_HighlitKeyCode = WXK_NONE;
		m_HighlitKeyModifier = wxMOD_NONE;
	}
}

//---- On Menu (Item) Closed event --------------------------------------------

void	TopFrame::OnMenuClosed(wxMenuEvent &e)
{
	e.Skip();

	if (0 != m_HighlitMenuID)
	{	m_HighlitMenuID = 0;
	
		wxLogMessage("highlit menu CLOSED");
	}
}

//---- On Mouse Capture Changed event -----------------------------------------

void	TopFrame::OnMouseCaptureChanged(wxMouseCaptureChangedEvent &e)
{
	e.Skip();
	
	wxWindow	*new_captured_win = e.GetCapturedWindow();
	if (!new_captured_win)		return;
	
	const int	win_id = new_captured_win->GetId();
	wxLogMessage("captured win id %d", win_id);
}

//---- On Key Down ------------------------------------------------------------

void	TopFrame::OnCharHookMenuAssign(wxKeyEvent &e)
{
	e.Skip();
	if (0 == m_HighlitMenuID)	return;				// ignore will no menu is selected
	
	const int	kc = e.GetKeyCode();
	const int	km = e.GetModifiers();
	
	// if ((kc == m_HighlitKeyCode) && (km == m_HighlitKeyModifier))	return;
	
	m_HighlitKeyCode = kc;
	m_HighlitKeyModifier = km;
	
	wxLogMessage("highlit key %d, mod %d", (int)kc, (int)km);
}

//---- On Mouse Swell started -------------------------------------------------

// EVT_STC_DWELLSTART(		-1,					EditorCtrl::OnDwellStart)

void	EditorCtrl::OnDwellStart(wxStyledTextEvent &e)
{
	assert(m_OwnerSFC);
	
	return;
	
	// if (!e.GetControl())				return;		// only on CONTROL down
	
	const int	pos = e.GetPosition();
	if (pos == wxSTC_INVALID_POSITION)		return;
	
	wxLogMessage("OnDwellStart(%d)", pos);
	
	string	word = GetToolTipWord(pos);
	wxLogMessage("  GetToolTipWord(%s)", wxString(word));
	
	if (word.empty())	return;
	
	// && !CallTipActive() && !m_ToolTipTimer.IsRunning())
	{
		// m_OwnerSFC->SolveVariable_ASYNC(word);
		
		// CallTipShow(pos, wxString::Format("tooltip %s = \"%s\"", wxString(word), wxString(val)));
		
		// CallTipSetBackground(wxColour())
		
		// m_ToolTipTimer.StartOnce(DDT_STC_TOOLTIP_TIMEOUT_MS);
	}
}

//--------------------------------------------------------------------

	m_ToolTipTimer.SetOwner(this, TIMER_ID_SFC_TOOLTIP);
	wxTimer			m_ToolTipTimer;
	EVT_TIMER(			TIMER_ID_SFC_TOOLTIP,			EditorCtrl::OnTootipTimer)
	
//--------------------------------------------------------------------

/*
// if (!IsClientActive() || !m_Client->IsConnected())	return;		// no active or not connected
	
	#if 0
	
	const int	notepage_index = m_BottomNotebook->GetSelection();
	
	wxLogMessage("TopFrame::UpdateBottomNotebookPage(page %d)", notepage_index);
	
	switch (notepage_index)
	{	case NOTEBOOK_PAGE_OUTPUT:
			
			break;
		
		case NOTEBOOK_PAGE_PROJECT:
		
			OnShowProjectSources();
			break;
			
		case NOTEBOOK_PAGE_LOCALS:
		case NOTEBOOK_PAGE_GLOBALS:
		case NOTEBOOK_PAGE_WATCHES:
		case NOTEBOOK_PAGE_MEMORY:
			
			if (m_Controller->IsClientActive() && m_Controller->IsLuaStarted())
				VarViewSettingsUpdated(notepage_index);
			break;
		
		case NOTEBOOK_PAGE_TRACEBACK:
	
			if (m_Controller->IsClientActive() && m_Controller->IsLuaStarted())
				m_TraceBackCtrl->DoUpdateCallStack();
			break;
		
		case NOTEBOOK_PAGE_BREAKPOINTS:
			
			// show breakpoints
			m_BreakpointsListCtrl->UpdateView();
			break;
		
		default:
			
			// else is nop
			break;
	}
*/

//---- Update MipMap ----------------------------------------------------------

void	TopNotebook::UpdateMipMap(SourceFileClass *sfc, const int &line1, const int &max_line)
{
	assert(m_MipMapStaticBitmap);
	assert(sfc);
	
	const int	w = m_MipMapStaticBitmap->GetClientSize().GetWidth();
	const int	h = m_MipMapStaticBitmap->GetClientSize().GetHeight();
	
	// wxLogMessage("m_MipMapStaticBitmap SIZE %d x %d", w, h);
	
	EditorCtrl	*ed = sfc->GetEditorCtrl();
	assert(ed);
	
	wxBitmap	bm(w, h, 32);
	wxMemoryDC	dc(bm);
	
	const wxRect	clip_rc(0, 0, w, h);
	
	dc.SetBrush(wxBrush(wxColour(255, 255, 255, 0xff), wxBRUSHSTYLE_SOLID));
	dc.SetPen(*wxTRANSPARENT_PEN);
	dc.DrawRectangle(clip_rc);
	
	for (int ln = 0; ln <= max_line; ln++)
	{
		vector<mipMapSpan>	span_list;
		vector<uint8_t>		density_tab;
			
		ed->GetLineStyleSpans(ln, span_list/*&*/, density_tab/*&*/);
		
		// wxLogMessage(" %zu spans, %zu densities (client_w %d)", span_list.size(), density_tab.size(), w);
		
		const double	pix_w = 4;	// (double) w / 80.0;
		// const double	pix_w = (double) w / 80.0;
		
		int	n = 0;
		
		for (const auto &span : span_list)
		{
			const int	len = span.m_Len;
			assert(len > 0);
			const wxColour	org_clr = span.m_Clr;
			
			// wxLogMessage("   span[%d, %d]", n, n + len);
			
			for (int x = n; x <= (n + len); x++)
			{
				const double	density = density_tab[x];
				const double	alpha = (density / 100.0);
				const double	inv_alpha = 1.0 - alpha;
				
				wxColour	clr = org_clr.ChangeLightness(100 + (inv_alpha * 100));
				
				dc.SetBrush(wxBrush(clr, wxBRUSHSTYLE_SOLID));
			
				// top-left & bottom-right
				wxPoint	tl(x, ln * 2);
				wxSize	sz(1, 1);
			
				tl.x *= pix_w;
				sz.x *= pix_w;
			
				const wxRect	rc(tl, sz);
			
				dc.DrawRectangle(rc);
			}
			
			n += len;
			// if (n >= 80)			break;
		}
	}
	
	dc.SelectObject(wxNullBitmap);
	
	m_MipMapStaticBitmap->SetBitmap(bm);
	
	m_MipMapStaticBitmap->Update();
}

//---- On Mouse Left Click ----------------------------------------------------

void	BottomNotebook::OnMouseLeftClick(wxMouseEvent &e)
{
	e.Skip();
	
	const wxPoint	pt{e.GetPosition()};
	
	wxString	res;
	long		mask = 0;
	
	const int	page_n = HitTest(pt, &mask);
	if (wxNOT_FOUND == page_n)		return;
	if (!(mask & wxBK_HITTEST_ONITEM))	return;		// nowhere we care
	
	// SourceFileClass	*sfc = GetNth(page);
	// assert(sfc);
	
	res << page_n;
	
	if (mask & wxBK_HITTEST_ONICON)
	{	// close button
		// HideSFC(sfc);
		res << " close";
	}
	else if (wxBK_HITTEST_ONLABEL & mask)
	{	// notepage label -> raise
		res << " label";
		
		// ChangeSelection(page_n);			// wxSTC may capture FOCUS here!
	
		// don't skip or cursor pos won't be restored!
		// e.Skip(false);
	}
	else	res << " none";
	
	wxLogMessage("mouse click \"%s\"", res);
}

//---- Update Bottom Notebook Page --------------------------------------------

void	TopFrame::UpdateBottomNotebookPage(void)
{
	assert(m_BottomNotePanel);
	assert(m_Client);
	assert(m_Controller);
	
	// if (!IsClientActive() || !m_Client->IsConnected())	return;		// no active or not connected
	
	const int	notepage_index = m_BottomNotebook->GetSelection();
	
	wxLogMessage("TopFrame::UpdateBottomNotebookPage(page %d)", notepage_index);
	
	switch (notepage_index)
	{	case NOTEBOOK_PAGE_OUTPUT:
			
			break;
		
		case NOTEBOOK_PAGE_PROJECT:
		
			// OnShowProjectSources();
			break;
			
		case NOTEBOOK_PAGE_LOCALS:
		case NOTEBOOK_PAGE_GLOBALS:
		case NOTEBOOK_PAGE_WATCHES:
		case NOTEBOOK_PAGE_MEMORY:
			
			// if (m_Controller->IsClientActive() && m_Client->IsConnected())
			if (m_Controller->IsClientActive() && m_Controller->IsLuaStarted())
				VarViewSettingsUpdated(notepage_index);
			break;
		
		case NOTEBOOK_PAGE_TRACEBACK:
	
			// if (m_Controller->IsClientActive() && m_Client->IsConnected())
			if (m_Controller->IsClientActive() && m_Controller->IsLuaStarted())
				m_TraceBackCtrl->DoUpdateCallStack();
			break;
		
		case NOTEBOOK_PAGE_BREAKPOINTS:
			
			// show breakpoints
			m_BreakpointsListCtrl->UpdateView();
			break;
		
		default:
			
			// else is nop
			break;
	}
}

//---- Var View Settings Updated ----------------------------------------------

void	TopFrame::VarViewSettingsUpdated(int page_index)
{
	assert(m_Controller);
	if (!m_Controller->IsClientActive())		return;		// ignore if not active
	
	if (-1 == page_index)		page_index = m_BottomNotebook->GetSelection();
	
	wxLogMessage("TopFrame::VarViewSettingsUpdated(page %d)", page_index);
	
	assert(m_Controller->IsLuaStarted());
	
	MemoryOutputStream	mos;
	
	switch (page_index)
	{
		case NOTEBOOK_PAGE_LOCALS:
		
			mos << CLIENT_MSG::REQUEST_LOCALS;
			mos << m_LocalsVarViewCtrl->GetVarRequest();
			break;
		
		case NOTEBOOK_PAGE_GLOBALS:
		
			mos << CLIENT_MSG::REQUEST_GLOBALS;
			mos << m_GlobalsVarViewCtrl->GetVarRequest();
			break;
		
		case NOTEBOOK_PAGE_WATCHES:
			
			mos << CLIENT_MSG::REQUEST_WATCHES;
			mos << m_WatchVarViewCtrl->GetVarRequest().SetWatchNames(m_WatchBag->Get());
			break;
		
		case NOTEBOOK_PAGE_MEMORY:
			
			mos << CLIENT_MSG::SOLVE_ONE_VARIABLE;
			mos << VariableRequest{SOLVE_CLIENT_MEMORY_VIEW, m_MemoryWatch};
			break;
		
		default:
			
			wxFAIL_MSG("illegal var view type");
			return;
			break;
	}
	
	// round-trip, then posts message back to TopFrame
	m_Client->RequestReply(mos);
}


static const
unordered_map<int, DDT::NOTEPAGE_ID>	s_WinToPageID
{
	{PANEL_ID_OUTPUT_TEXT_CTRL,		NOTEPAGE_ID_OUTPUT},
	{PANEL_ID_PROJECT_LIST,			NOTEPAGE_ID_PROJECT},
	{PANEL_ID_LOCALS_LIST_CONTROL,		NOTEPAGE_ID_LOCALS},
	{PANEL_ID_GLOBALS_LIST_CONTROL,		NOTEPAGE_ID_GLOBALS},
	{PANEL_ID_WATCH_LIST_CONTROL,		NOTEPAGE_ID_WATCHES},
	{PANEL_ID_TRACE_BACK_LIST_CONTROL,	NOTEPAGE_ID_STACK},
	{PANEL_ID_BREAKPOINTS_LIST_CONTROL,	NOTEPAGE_ID_BREAKPOINTS},
	{PANEL_ID_MEMORY_VIEW_CONTROL,		NOTEPAGE_ID_MEMORY}
};

//---- overlay (NOT WHAT I WANT) -------------------------------------

	// wxClientDC	dc(this);
	wxWindowDC	dc(this);
	PrepareDC(dc);
	
	wxDCOverlay	overlay_dc(m_Overlay, &dc);
	overlay_dc.Clear();
	
	dc.SetPen(*wxGREY_PEN);
	dc.SetBrush(wxColour(255, 192, 192, 255));
	
	wxRect	rc{pt, wxSize(50, 50)};
	
	dc.DrawRectangle(rc);
}

void	TopFrame::OnPaintEvent(wxPaintEvent &e)
{
	if (!m_OverlayFlag)	return;
	
	wxPaintDC	dc(this);
	
	wxMemoryDC	mdc(m_OverlayBitmap);
	
	dc.Blit(wxPoint(), GetClientSize(), &mdc, wxPoint());
	
	mdc.SelectObject(wxNullBitmap);
	
}

// Find the wxWindow at the current mouse position, also returning the mouse position
extern WXDLLIMPEXP_CORE wxWindow* wxFindWindowAtPointer(wxPoint& pt);

// Get the current mouse position.
extern WXDLLIMPEXP_CORE wxPoint wxGetMousePosition();

// get the currently active window of this application or NULL
extern WXDLLIMPEXP_CORE wxWindow *wxGetActiveWindow();

// get the (first) top level parent window
WXDLLIMPEXP_CORE wxWindow* wxGetTopLevelParent(wxWindow *win);

//--------------------------------------------------------------------

	wxWindow	*win = ::wxFindWindowAtPoint(gpt);

	if (win)
	{	
		int	id = win->GetId();
		
		while (win && (id <= DDT_CONTROL_ID_FIRST) && (id >= DDT_CONTROL_ID_LAST))
		{
			win = win->GetParent();
			if (win)	id = win->GetId();
		}

		SetStatusText(wxString::Format("OnMouseMove(%d)", id), 0);
	}
	else	SetStatusText(wxString::Format("OnMouseMove(none)"), 0);

//--------------------------------------------------------------------

	wxFont	normal(wxFontInfo(9).Family(wxFONTFAMILY_SWISS).Encoding(wxFONTENCODING_DEFAULT).Light());
	wxFont	bold(wxFontInfo(10).Family(wxFONTFAMILY_SWISS).Encoding(wxFONTENCODING_DEFAULT).Bold());
	
	for (BottomNotebook *bnb : m_Books)
	{
		const bool	f = (book_index == bnb->m_BookIndex);
		/*
		long	styl = GetWindowStyle();
		
		if (book_index == bnb->m_BookIndex)
		{
			styl |= wxBORDER_DOUBLE;
		}
		else	styl &= ~wxBORDER_DOUBLE;
		
		bnb->SetWindowStyle(styl);
		
		bnb->Update();
		*/
		
		// bnb->SetForegroundColour(f ? wxColour(0, 255, 0) : wxColour(255, 255, 255));
		bnb->SetBackgroundColour(f ? wxColour(200, 255, 200) : wxColour(255, 255, 255));
		
		bnb->Refresh();
	}

//--------------------------------------------------------------------

	wxMenu	menu(wxString::Format("%s", wxString(pinfo.GetName())));
	
	menu.Append(CONTEXT_MENU_ID_TO_TOP_LEFT, "move to Top-Left");
	menu.Append(CONTEXT_MENU_ID_TO_TOP_RIGHT, "move to Top-Right");
	menu.Append(CONTEXT_MENU_ID_TO_BOTTOM_LEFT, "move to Bottom-Left");
	menu.Append(CONTEXT_MENU_ID_TO_BOTTOM_RIGHT, "move to Bottom-Right");
	menu.AppendSeparator();
	menu.Append(CONTEXT_MENU_ID_REMOVE_PAGE, "Remove");
	
	// immediate popup menu -- will send FOCUS event
	const int	menu_id = GetPopupMenuSelectionFromUser(menu);
	e.Skip();				// release mouse
	if (menu_id < 0)	return;		// canceled
	
	switch (menu_id)
	{	case CONTEXT_MENU_ID_REMOVE_PAGE:
			
			RemovePageID(page_id);
			break;
			
		case CONTEXT_MENU_ID_TO_TOP_LEFT:
		case CONTEXT_MENU_ID_TO_TOP_RIGHT:
		case CONTEXT_MENU_ID_TO_BOTTOM_LEFT:
		case CONTEXT_MENU_ID_TO_BOTTOM_RIGHT:
		{
			assert(s_ContextMenuToBookID.count(menu_id) > 0);
			const int	book_index = s_ContextMenuToBookID.at(menu_id);
			
			RemovePageID(page_id);
			m_BottomNotePanel->AddPageToNotebook(page_id, book_index);
		}	break;
		
		default:
		
			wxLogMessage("not implemented");
			break;
	}

//--------------------------------------------------------------------

//---- Get Line Style Spans ---------------------------------------------------

void	EditorCtrl::GetLineStyleSpans(const int &lua_ln, vector<mipMapSpan> &span_list, vector<uint8_t> &density_tab)
{
	span_list.clear();
	density_tab.clear();
	
	assert(lua_ln != -1);
	const int	ln = lua_ln - 1;
	
	const int	pos1 = PositionFromLine(ln);
	const int	pos2 = GetLineEndPosition(ln);		// is beyond last char ?
	const int	dpos = pos2 - pos1;
	if (dpos == 0)	return;		// empty line
	
	const int	lnlen = GetLineLength(ln);
	if (lnlen == 0)	return;		// empty line
	const int	styled_ln_len = (lnlen + 1) * 2;
	
	uint8_t		styled_line[styled_ln_len];
	
	const int	received_sz = OnGetStyledText2((char*)&styled_line[0], styled_ln_len, pos1, pos2);
	assert(received_sz != 0);
	
	// wxLogMessage(" ln[%d] span(%d, %d), dpos(%d), lnlen = %d", lua_ln, pos1, pos2, dpos, lnlen);
	
	wxColour	last_clr;
	int		n = 0;		// should never be zero after 1st span is sent out
	
	for (int i = 0; i < lnlen; i++)
	{
		const char	c = styled_line[(i * 2) + 0];
		const uint8_t	styl = styled_line[(i * 2) + 1];
		
		// wxLogMessage(" char: %c, styl: 0x%02x", c, styl);
		
		const int	char_w = (c == '\t') ? DDT_TAB_CHAR_SIZE : 1;
		const wxColour	clr = ((c != 0x20) && (c != '\t')) ? m_StyleColorLUT[styl] : *wxWHITE;
		
		const uint8_t	density = m_CharDensityLUT[(uint8_t)c];
		density_tab.insert(density_tab.end(), char_w, density);
		
		if ((0 == i) || (clr == last_clr))
		{
			n += char_w;
			last_clr = clr;		// (just for 1st span)
		}
		else
		{	// finish last span
			if (n > 0)	span_list.push_back(mipMapSpan{n, last_clr});
			
			last_clr = clr;
			n = char_w;
		}
	}
	
	// last span
	if (n > 0)	span_list.push_back(mipMapSpan{n, last_clr});
	
	// wxLogMessage(" %d density entries", (int) density_tab.size());
}

//---- Compute Font Density ---------------------------------------------------

void	EditorCtrl::CalcFontDensity(const int &font_size)
{
	// wxLogMessage("EditorCtrl::CalcFontDensity()");
	
	wxFont		ft(wxFontInfo(font_size).Family(wxFONTFAMILY_MODERN));
	
	const wxSize	sz = ft.GetPixelSize();
	const int	w = sz.GetWidth();
	const int	h = sz.GetHeight();
	
	wxMemoryDC	dc;
	wxBitmap	bm(w, h, 8/*depth*/);
	dc.SelectObject(bm);
	
	// clear bitmap
	dc.SetBackground(*wxBLACK_BRUSH);
	dc.Clear();
	
	dc.SetMapMode(wxMM_TEXT);
	dc.SetFont(ft);
	
	dc.SetTextForeground(*wxWHITE);
	dc.SetPen(*wxTRANSPARENT_PEN);
	
	int	max_dense_index = -1;
	int	max_density = -1;
	wxImage	img;
	
	for (int i = 0; i < 256; i++)
	{
		m_CharDensityLUT[i] = 0;
		
		const char	c = (char)i;
		if (!isprint(c))	continue;	// not printable
		
		// clear bitmap
		dc.SetBackground(*wxBLACK_BRUSH);
		dc.Clear();
		
		const wxString	s = wxString(c);
		
		dc.DrawText(s, 0/*x*/, 0/*y*/);
		
		img = bm.ConvertToImage();
		img.ConvertToGreyscale();
		
		img.Rescale(1, 1);
		
		const int	density = img.GetRed(0, 0);
		if (density > max_density)
		{	max_dense_index = i;
			max_density = density;
		}
		
		m_CharDensityLUT[i] = density;
		
		// wxLogMessage(" char \"%s\", density %d", s, density);
	}
	
	// wxLogMessage("max density: \"%s\" @ %d", wxString((char)max_dense_index), max_density);
	
	dc.SelectObject(wxNullBitmap);
}

//--------------------------------------------------------------------

	const int		DDT_STC_MOUSE_DWELL_TIME_MS		= 700;
	
	SetMouseDwellTime(DDT_STC_MOUSE_DWELL_TIME_MS);
	
//--------------------------------------------------------------------

// precompute stylecolor LUT
	
	wxColour		m_StyleColorLUT[256];
	uint8_t			m_CharDensityLUT[256];
	
	
	// default all to white
	for (int i = 0; i < 256; i++)			m_StyleColorLUT[i] = (*wxWHITE);
	
	// punch-in Lua lexer colors
	for (const auto &it : s_LuaStyleLUT)
	{
		const int	lex_id = it.first;
		assert((lex_id >= 0) && (lex_id < 256));
		
		const wxColour	clr = StyleGetForeground(lex_id);
		
		// const uint32_t	pix32 = clr.GetRGBA();
		// const uint32_t	pix32 = clr.GetRGB();
		
		m_StyleColorLUT[lex_id] = clr;
	}
	

void	TopNotebookImp::OnRightDown(wxMouseEvent &e)
{
	// e.Skip();
	
	long		mask = 0;
	
	const int	page_index = HitTest(e.GetPosition(), &mask);
	if (wxNOT_FOUND == page_index)		return;
	if (!(mask & wxBK_HITTEST_ONITEM))	return;		// nowhere we care
	
	// m_PageList
}

//---- Remove All Pages -------------------------------------------------------

void	BottomNotePanel::RemoveAllPages(void)
{
	for (int id = 0; id < PANE_ID_MAX; id++)	RemovePageID(id);
	
	m_TopFrame->DirtyUIPrefs();
}

//---- Get MixIn from wxWindow ------------------------------------------------

BottomPageMixIn*	BottomNotePanel::GetWinToMixIn(wxWindow *w) const
{
	assert(w);
	
	assert(m_WinToMixInHash.count(w) > 0);
	
	BottomPageMixIn	*mix_in = m_WinToMixInHash.at(w);
	assert(mix_in);
	
	return mix_in;
}

//---- Hide from Book ---------------------------------------------------------

void	SourceFileClass::HideFromBook(void)
{
	assert(m_TopNotebookImp);
	assert(m_EditorCtrl);
	
	m_TopNotebookImp->RemovePage(m_PageIndex);
	m_EditorCtrl->Hide();
	
	m_PageIndex = -1;
}

//---- Add Disabled Panes -----------------------------------------------------

void	BottomNotePanel::AddDisabledPanes(void)
{
	for (int i = 0; i < PANE_ID_MAX; i++)
	{
		PageInfo	&pinfo = PageID(i);
		if (pinfo.IsUsed())		continue;
	
		AddPageToNotebook(i, 3);
	}
}

//---- On Dump DDT Project ----------------------------------------------------

void	TopFrame::OnDumpDDTProject(wxCommandEvent &e)
{
	assert(m_Controller);
	
	wxFileDialog	dlg(	this, "Dump DDT Project", wxGetCwd(), "",
				"ddt files (*.ddt)|*.ddt",
				wxFD_OPEN | wxFD_FILE_MUST_EXIST);
				
	const int	res = dlg.ShowModal();
	if (res == wxID_CANCEL)		return;
}

//---- On Add Hidden Panes ----------------------------------------------------

void	TopFrame::OnAddHiddenPanes(wxCommandEvent &e)
{
	assert(m_BottomNotePanel);
	
	wxLogMessage("TopFrame::OnAddHiddenPanes()");
	
	// SetStatusError("test");
	
	m_BottomNotePanel->AddDisabledPanes();
	
	e.Skip();
}

//---- Page Pos to Page ID ----------------------------------------------------

int	BottomNotebook::PagePosToID(const int &page_index)
{
	if (page_index == wxNOT_FOUND)		return PANE_ID_NONE;
	
	BottomPageMixIn	*mix_in = PagePosToMixIn(page_index);
	assert(mix_in);
	
	return mix_in->GetPageID();
}

//---- Flush VIEW -------------------------------------------------------------
	
	// would be a log override wxLog::Flush() 
	
void	OutputTextCtrl::FlushLog(void)
{
	// ScrollToEnd();
	
	// MarkDirty();
	
	// immediate redraw
	// Refresh();			// do NOT call Refresh here!!! will eat all CPU
	
	// would infinite-loop
	// wxLog::FlushActive();
}

//MyApp	*app = wxGetApp();
	
	// wxWindow	*w = wxGetApp().GetTopWindow();
	wxWindow	*w = wxTheApp->GetTopWindow();
	if (!w)		return;
	
	w = w->FindWindow(CONTROL_ID_TOP_FRAME);
	if (!w)		return;
	
	TopFrame	*tf = dynamic_cast<TopFrame*> (w);
	
//====================================================================
	
	m_SashTopLeft->SetOrientation(wxLAYOUT_VERTICAL);
	m_SashTopLeft->SetAlignment(wxLAYOUT_LEFT);
	m_SashTopLeft->SetSashVisible(wxSASH_RIGHT, true);
	
	m_SashTopRight = new wxSashLayoutWindow(this, SASH_ID_TOP_RIGHT, wxDefaultPosition, wxSize(400, 600), wxNO_BORDER | wxSW_3D);
	m_SashTopRight->SetOrientation(wxLAYOUT_VERTICAL);
	m_SashTopRight->SetAlignment(wxLAYOUT_RIGHT);
	m_SashTopRight->SetSashVisible(wxSASH_LEFT, true);
	
	m_SashMidDummy = new wxSashLayoutWindow(this, SASH_ID_MID_DUMMY, wxDefaultPosition, wxSize(400, 600), wxNO_BORDER | wxSW_3D);
	m_SashMidDummy->SetOrientation(wxLAYOUT_HORIZONTAL);
	m_SashMidDummy->SetAlignment(wxLAYOUT_TOP);
	// m_SashMidDummy->SetSashVisible(wxSASH_LEFT, true);
	
static const
unordered_map<int, bookMul>	s_SplitterBookLUT
{	
	{SPLITTER_TOP_LEFT,	{0, 1}},
	{SPLITTER_TOP_RIGHT,	{1, -1}},
	{SPLITTER_BOTTOM,	{3, -1}}
};

//---- Get Splitter Widths ----------------------------------------------------

vector<int>	BottomNotePanel::GetSplitterWidths(const vector<int> &book_widths) const
{
	assert(book_widths.size() == PANEBOOK_MAX);
	
	for (int i = 0; i < book_widths.size(); i++)
	{
		wxLogMessage("book width%d = %d", i, book_widths[i]);
	}
	
	// m_TopFrame->DumpWindow(this, "BottomNotePanel");
	
	const int	full_w = m_TopFrame->GetSize().GetWidth();
	
	vector<int>	splitter_widths;
	
	splitter_widths.push_back(book_widths[0]);
	splitter_widths.push_back(book_widths[2]);
	
	wxLogMessage("full width: %d", full_w);
	wxLogMessage("splitter0: %d", splitter_widths[0]);
	wxLogMessage("splitter1: %d", splitter_widths[1]);
	
	/*
	for (int i = 0; i < SPLITTER_LAST; i++)
	{
		assert(s_SplitterBookLUT.count(i) == 1);
		const bookMul	&bmul = s_SplitterBookLUT.at(i);
		
		const int	split_w = book_widths.at(bmul.m_BookID) * bmul.m_Factor;
		
		splitter_widths.push_back(split_w);
	}
	*/
	
	assert(splitter_widths.size() == SPLITTER_LAST);
	
	return splitter_widths;
}

//---- Get Book Widths --------------------------------------------------------

vector<int>	BottomNotePanel::GetBookWidths(void) const
{
	vector<int>	widths;
	
	for (const auto book : m_Books)
	{	assert(book);
		
		// zero width if has no pages
		const int	w = book->HasPages() ? book->GetSize().GetWidth() : 0;			// should get CLIENT size?
		
		widths.push_back(w);
	}
	
	assert(widths.size() == PANEBOOK_MAX);
	
	return widths;
}

//--------------------------------------------------------------------
	
	wxEventFilter
	// get event info
	const wxClassInfo	*info = e.GetClassInfo();
	assert(info);
		
	// get event type name
	const wxString		typ_str = info->GetClassName();
	assert(!typ_str.IsEmpty());
	
	const int	id = e.GetId();
	
	wxWindow	*win = FindWindow(id);
	wxASSERT_MSG(win, "StartupDlg::OnWatchedEvent couldn't FindWindow()");

	// get control label/title/name
	const wxString	label = win->GetLabel();
	
	// get class info
	const wxClassInfo	*class_info = win->GetClassInfo();
	assert(class_info);
	
	// get class type name
	const wxString		class_type = class_info->GetClassName();
	assert(!class_type.IsEmpty());
	
	// uLogInfo("%s(%d), label \"%s\", class %s, extra \"%s\"", typ_str, id, label, class_type, e.GetString());
	
//---- Get Page List Buffer ---------------------------------------------------

wxString	BottomNotePanel::GetPageListBuffer(const vector<int> &page_list)
{
	ostringstream	ss(ios_base::out | ios_base::trunc);
	
	ss << page_list.size() << endl;
	
	for (const int id : page_list)
	{
		const PageInfo	&pinfo = PageID(id);
		
		ss << pinfo.GetName() << endl << pinfo.GetBookID() << endl;
	}
	
	// (mark end ?)
	ss << endl;
	
	return wxString(ss.str());
}	
	
//--------------------------------------------------------------------

	bool	ok;
	
	if (IsSplit())
	{	ok = ReplaceWindow(GetWindow1(), w1);
		ok &= ReplaceWindow(GetWindow2(), w2);
		SetSashPosition(pos);
	}
	else	ok = SplitVertically(w1, w2, pos);
	
	assert(ok);
//---- Recalc Mask ------------------------------------------------------------

void	PaneBook::RecalcMask(void)
{
	assert(m_Notebook);
	
	m_HostMask = m_Notebook->GetScreenRect();
	m_ClientMask = wxRect();
	
	#if 0
	// area needed to accommodate controller
	wxSize	c_area = m_Notebook->GetControllerSize();
	
	int	border = m_Notebook->GetInternalBorder();
	int	margin = m_Notebook->GetControlMargin();
	
	const wxPoint	offset = m_Notebook->GetClientAreaOrigin();
	wxRect		rc = m_Notebook->GetClientRect();
	
	wxSizer	*ctrl_sizer = m_Notebook->GetControlSizer();
	
	#endif
	// get the page area
	// wxRect	pg_area = m_Notebook->GetPageRect();		// PROTECTED member

}
	
#if 0
	// returns size enough to fit both the page and the controller
	virtual wxSize CalcSizeFromPage(const wxSize& sizePage) const;

	// get/set size of area between book control area and page area
	unsigned int GetInternalBorder() const { return m_internalBorder; }
	void SetInternalBorder(unsigned int border) { m_internalBorder = border; }

	// Sets/gets the margin around the controller
	void SetControlMargin(int margin) { m_controlMargin = margin; }
	int GetControlMargin() const { return m_controlMargin; }

#endif

void	TopFrame::OnRequestLuaFunctions(wxCommandEvent &e)
{
	assert(m_Controller);
	assert(m_Client);
	if (!m_Controller->IsLuaListening())		return;
	
	const VAR_SOLVE_REQUESTER	requester_id = VAR_SOLVE_REQUESTER::SOLVE_REQUESTER_FUNCTIONS;

	MemoryOutputStream	mos;
	
	mos << CLIENT_MSG::REQUEST_GLOBAL_FUNCTIONS;
	mos << VariableRequest{requester_id, "dummy"};
	
	bool	ok = m_Client->RequestReply(mos);
	assert(ok);
}

//---- On Save/Load UI Cycle --------------------------------------------------

void	TopFrame::OnSaveLoadUICycle(wxCommandEvent &e)
{
	wxLogMessage("TopFrame::OnSaveLoadUICycle()");
	assert(m_BottomNotePanel);
	
	vector<int>	ws1, ws2;
	
	ws1 = m_BottomNotePanel->GetSplitterWidths();
	
	serializ("ws1 normal", ws1);

	ws2 = m_BottomNotePanel->GetSplitterWidths(true);
	
	serializ("ws2 pre-drag", ws2);
}

//---- On Escape Char Hook ----------------------------------------------------

void	TopNotePanel::OnEscapeCharHook(wxKeyEvent &e)
{
	// e.Skip();
	
	const int	k = e.GetKeyCode();
	if (k == WXK_ESCAPE)
	{
		CallAfter(&TopNotePanel::EscapeKeyCallback);
	}
	
	e.Skip();
	// e.DoAllowNextEvent();
}

//--------------------------------------------------------------------
	
{
	const VAR_SOLVE_REQUESTER	requester_id = VAR_SOLVE_REQUESTER::SOLVE_REQUESTER_FUNCTIONS;
	
	MemoryOutputStream	mos;

	mos << CLIENT_MSG::REQUEST_GLOBAL_FUNCTIONS;
	mos << VariableRequest{requester_id, "dummy"};

	bool	ok = m_Client->RequestReply(mos);
	assert(ok);
}

//--------------------------------------------------------------------

template<int lvl>
void	uLog(const char *msg)
{
	ddtLog::DoULog_LL(lvl, std::string(msg));
}

template<int lvl>
void	uLog(const wxString &msg)
{
	ddtLog::DoULog_LL(lvl, msg.ToStdString());
}

template<int lvl, typename T, typename ... Args>
void	uLog(const char *fmt, T this_val, Args ... args)
{
	const std::string	msg = LX::xsprintf(fmt, this_val, args ...);
	
	ddtLog::DoULog_LL(lvl, msg);
}

//--------------------------------------------------------------------

void	TopFrame::OnWindowDestroyedEvent(wxWindowDestroyEvent &e)
{
	wxWindow	*w = e.GetWindow();
	assert(w);
	
	const int	id = w->GetId();
	
	const string	name = GetWinIDName(id);
	
	uLog(DTOR, "OnWindowDestroyedEvent(%s)", wxString(name));
}

//---- Draw Over X11 ----------------------------------------------------------

void	TopFrame::DrawOverX11(const wxPoint &pt, const int &radius)
{
	// uMsg("TopFrame::DrawOverX11(pt %d, %d, radius %d)", pt.x, pt.y, radius);
	
	wxScreenDC::StartDrawingOnTop(this);
	
	wxScreenDC	dc;
	
	wxPen	transparent_pen(wxColour(0xff, 0, 0, 0), 1, wxPENSTYLE_SOLID);
	wxBrush	no_brush(wxColor(0, 0, 0, 0), wxBRUSHSTYLE_TRANSPARENT);
	
	dc.SetPen(transparent_pen);
	dc.SetBrush(no_brush);
	dc.SetLogicalFunction(wxINVERT);
	
	dc.DrawCircle(pt, radius);
	
	wxScreenDC::EndDrawingOnTop();
}

//---- On Circle Timer --------------------------------------------------------

void	TopFrame::OnCircleTimer(wxTimerEvent &e)
{
	/*
	// erase last
	if (MOUSE_CLICK_RADIUS_START != m_LastRadius);
		DrawOverX11(m_CirclePt, m_LastRadius);
	*/
	
	const int32_t	elap_ms = xelap_ms(m_CircleStartStampMS);
	if (elap_ms >= MOUSE_CLICK_RADIUS_TIMER_TOTAL_MS)
	{	// stop growth
		m_Timers[CIRCLE].Stop();
	}
	else
	{	// expand
		m_OverlayFrame->StepAnimation();
		// m_LastRadius *= 2;
		// DrawOverX11(m_CirclePt, m_LastRadius);
	}
}

//--------------------------------------------------------------------
			
	case DAEMON_MSG::REPLY_GLOBAL_FUNCTIONS:
	{
		assert(m_TopNotePanel);
		
		requester_id = mis.Read32();
		assert(requester_id == SOLVE_REQUESTER_FUNCTIONS);
		
		CollectedList	collist{mis};
		
		m_TopNotePanel->DispatchFunctionBookmarks(collist);
	}	break;

//--------------------------------------------------------------------

	// set to auto-size AFTER filled the list (otherwise will be zero)
	#ifdef __WIN32__
		const int	AUTO_SZ = wxLIST_AUTOSIZE_USEHEADER;
	#else
		const int	AUTO_SZ = wxLIST_AUTOSIZE;
	#endif
	
	for (int i = 0; i < GetColumnCount(); i++)	SetColumnWidth(i, AUTO_SZ);

//---- Request & Reply (SYNCHRONOUS round-trip) -------------------------------

bool	Client::RequestReply_SYNC(const MemoryOutputStream &mis, vector<uint8_t> &buff)
{
	if (!CheckConnection())		return false;
	
	// bool	ok = LogOutgoingMessageType(mos, "Client::GetRequestReply() ");
	// assert(ok);
	
	bool	ok = m_ClientTCP->WriteMessage(mis);
	if (!ok)
	{	wxLogError("  write failed");
		return false;
	}
	
	ok = m_ClientTCP->ReadMessage(buff/*&*/);
	if (!ok)
	{	wxLogError("  read failed");
		return false;
	}
	
	return ok;
}

//--------------------------------------------------------------------

	{wxLOG_FatalError,	CONSOLE_COLOR::RED},
	{wxLOG_Error,		CONSOLE_COLOR::RED},
	{wxLOG_Warning,		CONSOLE_COLOR::ORANGE},
	{wxLOG_Message,		CONSOLE_COLOR::BLACK},
	{wxLOG_Status,		CONSOLE_COLOR::DARK_GREY},
	{wxLOG_Info,		CONSOLE_COLOR::DARK_GREY},
	{wxLOG_Debug,		CONSOLE_COLOR::GREY},
	{wxLOG_Trace,		CONSOLE_COLOR::INVALID},
	{wxLOG_Progress,	CONSOLE_COLOR::INVALID},

//--------------------------------------------------------------------

template<typename _T>
string	ttest(const _T& val)		// can't use r-val ref for val
{
	string		res;
	
	const bool	int_f = is_integral<_T>();
	res.append(int_f ? "int_f " : " ");
	
	const bool	wxstring_f = is_same<_T, wxString>();
	res.append(wxstring_f ? "wxstring_f " : " ");
	
	const bool	wxstring_nr_f = is_same< remove_reference<_T>, wxString>();
	res.append(wxstring_f ? "wxstring_nr_f (no ref) " : " ");
	
	const bool	rval_ref_f = is_rvalue_reference<_T>();
	res.append(rval_ref_f ? "rval_ref_f " : " ");
	
	const bool	lval_ref_f = is_lvalue_reference<_T>();
	res.append(lval_ref_f ? "lval_ref_f " : " ");
	
	const bool	ref_f = is_reference<_T>();
	res.append(ref_f ? "ref_f " : " ");
	
	return res;
}

//--------------------------------------------------------------------
	// chop trailing (u)nsigned
	if (*s == 'u')
	{
		if (int_f && (fmt_c != 'u'))
			s++;	// skip
		else	throw runtime_error("bad xsprintf() trailing (u)nsigned specifier on non-integral arg");
	}
	
//--------------------------------------------------------------------

	int	ui_id = VAR_UI_DEFAULT;
	// if (ce.IsLuaFileFunction())		ui_id = VAR_UI_EDITOR_URL;	// editor url
	// else if (ce.IsHugeString())		ui_id = VAR_UI_MEMORY_URL;	// memory url
	// else if (mask & VAR_FLAG_CHANGED)	ui_id = VAR_UI_CHANGED_VAL;	// changed
		
	if ((ce.GetType() == CTYPE_STRING) || (ce.GetType() == CTYPE_LUA_STRING_FUNCTION))
	{	const size_t	str_sz = ce.m_ValS.length();
		if (ce.IsHugeString() || (!ce.IsPrintableString()))
		{	// huge Lua string
			SetItem(row, COLUMN_VAL_STR, wxString::Format("[%zu chars]", str_sz), BITMAP_ID_PLUS);
		}
		else
		{	// decorated string
			SetItem(row, COLUMN_VAL_STR, wxString(ce.GetDecoratedVal()));
		}
	}
	else
	{	if (ce.IsBinaryData())
		{	const size_t	str_sz = ce.m_ValS.length();
			
			SetItem(row, COLUMN_VAL_STR, wxString::Format("[%zu bytes]", str_sz), BITMAP_ID_PLUS);
		}
		else	SetItem(row, COLUMN_VAL_STR, wxString(ce.GetDecoratedVal()));
	}

//--------------------------------------------------------------------

	const wxSize	item_spacing = GetItemSpacing();
	uMsg("*** item_spacing (%d, %d)", item_spacing.x, item_spacing.y);
	
	const wxPoint	mouse2 = ScreenToClient(::wxGetMousePosition());
	// uMsg("*** mouse 2 (%d, %d)", mouse2.x, mouse2.y);
	
	// const int	mouse_dy = mouse2.y - pt.y;				// 23 or zero, depending on header shown
	// uMsg("*** mouse dy (%d)", mouse_dy);
	
	const wxPoint	client_origin = GetClientAreaOrigin();
	// uMsg("*** client area origin (%d, %d)", client_origin.x, client_origin.y);

	const wxPoint	client_to_screen00 = ClientToScreen(wxPoint(0, 0));
	// uMsg("*** client to screen (%d, %d)", client_to_screen00.x, client_to_screen00.y);

	const wxPoint	pos_in_screen = GetScreenPosition();		// this blows
	// uMsg("*** pos_in_screen (%d, %d)", pos_in_screen.x, pos_in_screen.y);

	const wxRect	view_rect = GetViewRect();
	// uMsg("*** view_rect (%d, %d, %d, %d)", view_rect.x, view_rect.y, view_rect.width, view_rect.height);
	
	const wxRect	client_rect = GetClientRect();
	// uMsg("*** client_rect (%d, %d, %d, %d)", client_rect.x, client_rect.y, client_rect.width, client_rect.height);	
	
	const wxPoint	unscrolled = CalcUnscrolledPosition(wxPoint(0, 0));
	// uMsg("*** unscrolled (%d, %d)", unscrolled.x, unscrolled.y);
	
	const wxPoint	scrolled = CalcScrolledPosition(wxPoint(0, 0));
	// uMsg("*** scrolled (%d, %d)", scrolled.x, scrolled.y);
	
	const wxPoint	view_start = GetViewStart();
	// uMsg("*** view_start (%d, %d)", view_start.x, view_start.y);
	
//---- On Mouse Left Down -----------------------------------------------------

void	VarViewCtrl::OnMouseLeftDown(wxMouseEvent &e)
{
	assert(m_TopFrame);
	assert(m_ListCtrl);
	
	int	flags;
	long	col = -1;	// not implemented
	
	const int	row = m_ListCtrl->HitTest(e.GetPosition(), flags/*&*/, &col);
	
	// test watch edit first (or would crash)
	if ((row == m_Cnt) && IsEditable())
	{
		m_ListCtrl->EditLabel(row);
		e.Skip();
	}
	
	// should SKIP for when changing NotePage ?
}

//--------------------------------------------------------------------

	uMsg(" no HitTest2");
	
	// old hittest
	row = HitTest(pt, flags/*&*/);
	if (row != -1)
	{
		uMsg(" vanilla hittest() row %d", row);
		
		if (IsEditable())
		{	// watches
			if (row == GetItemCount() - 1)
			{	// adding watch
				uMsg("  watch EDIT");
				EditLabel(row);
				// e.Skip();
			}
			else
			{	// select watch line
				uMsg("  watch SELECT");
				SelectItem(row);
				// e.Skip();
			}
			return;
		}
		else
		{	// clicked non-watch outside hotrect
		}
		
		return;
	}

//--------------------------------------------------------------------

	uMsg("TopFrame::OnMainHSplitterSashChanged()");
	uMsg("  sash pos = %d", pos);
	
	wxWindow	*win1 = m_MainSplitterWindow->GetWindow1();
	if (win1)
	{	uMsg("  height 1 = %d", win1->GetSize().y);
		uMsg("  client height 1 = %d", win1->GetClientSize().y);
	}
	
	wxWindow	*win2 = m_MainSplitterWindow->GetWindow2();
	if (win2)
	{	uMsg("  height 2 = %d", win2->GetSize().y);
		uMsg("  client height 2 = %d", win2->GetClientSize().y);
	}
	
	uMsg("");

//--------------------------------------------------------------------

	if ((id == SPLITTER_ID_VERTICAL_TOP_LEFT) && ::wxGetKeyState(WXK_CAPITAL))
	{
		assert(m_TopNotePanel);
		wxSplitterWindow	*sw = m_TopNotePanel->m_SplitterTop;
		assert(sw);
		
		DumpSplitter(sw, "m_SplitterTopLeft");
	}

//--------------------------------------------------------------------

	if (ce.IsHugeString())	menu.Append(VARVIEW_CONTEXT_MENU_ID_INSPECT_MEMORY, "Inspect Memory");
	if (ce.IsLuaFileFunction())	menu.Append(VARVIEW_CONTEXT_MENU_ID_GOTO_FUNCTION, "goto function");
	if (menu.GetMenuItemCount() > 0)	menu.AppendSeparator();
	
	case VARVIEW_CONTEXT_MENU_ID_INSPECT_MEMORY:
	{	// open large string in Memory viewer (wx click detection on inline icon blows)
		const string	key_name = ce.GetKey();
		
		m_TopFrame->CallAfter(&TopFrame::SetMemoryWatch, key_name);
	}	break;
	
	case VARVIEW_CONTEXT_MENU_ID_GOTO_FUNCTION:
	{
		string	sourcename;
		int	ln;
		
		bool	ok = ce.GetLuaFileFunction(sourcename/*&*/, ln/*&*/);
		assert(ok);
		
		m_TopFrame->CallAfter(&TopFrame::ShowSourceAndLineIntra, sourcename, ln);
		m_TopFrame->CallAfter(&TopFrame::SetSourceFocus, sourcename);
	}	break;

//--------------------------------------------------------------------

	for (int i = 0; i < 31; i++)
	{
		size_t	len = (1L << i) - 1;
		
		int	nybbles = ((std::log2(len) / 4) + 1);
		uMsg("mem sz 0x%08x, nybbles %2d", len, nybbles);

		len++;
		nybbles = ((std::log2(len) / 4) + 1);
		uMsg("mem sz 0x%08x, nybbles %2d", len, nybbles);
	}

//--------------------------------------------------------------------

void	OnFitColumns(void)
{
	const int	n_rows = GetItemCount();
	const int	n_cols = GetColumnCount();
	
	wxClientDC	dc(this);
	
	for (int col = 0; col < n_cols; col++)
	{
		int	max_w = 0;
		
		for (int row = 0; row < n_rows; row++)
		{
			const wxString		s = OnGetItemText(row, col);
			const wxListItemAttr	*attr = OnGetItemColumnAttr(row, col);
			assert(attr);
			const wxFont		*font = &attr->GetFont();
			assert(font);
			
			wxCoord	w, h, descent, leading;
			
			dc.GetTextExtent(s, &w, &h, &descent, &leading, font);
			
			if (w > max_w)		max_w = w;
		}
		
		SetColumnWidth(col, max_w + 8);
	}
}

//--------------------------------------------------------------------

CallAfter(&ProjectList::OnFitColumns);

virtual
wxString	OnGetItemText(long row, long col) const
{
	assert(m_Controller);
	
	SourceFileClass	*sfc = GetNthSFC(row);
	
	const SFC_props		&props = sfc->GetProperties();
	const bool		MD5_ok_f = props.m_MD5okFlag;
	const vector<wxString>	&list = props.m_List;
	
	assert(s_PropToIndexMap.count(col) > 0);
	
	const int	prop_index = s_PropToIndexMap.at(col);
	assert(prop_index < list.size());
	
	return list[prop_index];
}

virtual
wxListItemAttr*	OnGetItemAttr(long row) const
{
	return &(m_AttrList[0]);
}

virtual
wxListItemAttr*	OnGetItemColumnAttr(long row, long col) const
{
	// return &(m_AttrList[(row & 1) ^ (col & 1)]);
	return &(m_AttrList[0]);
}

virtual
int	OnGetItemImage(long row) const
{
	return -1;
}

//--------------------------------------------------------------------

void	FitColumns(void)
{
	const int	n_rows = GetItemCount();
	
	wxClientDC	dc(this);
	const wxFont	*ft_ptr = & dc.GetFont();
	
	for (int col = 0; col < GetColumnCount(); col++)
	{
		int	max_w = 0;
		
		for (int row = 0; row < n_rows; row++)
		{
			wxListItem	li;
			
			li.m_itemId = row;
			li.m_col = col;
			
			const bool	ok = GetItem(li/*&*/);
			assert(ok);
			
			wxCoord	w, h, descent, leading;
			
			dc.GetTextExtent(li.m_text, &w, &h, &descent, &leading, ft_ptr);
			
			if (w > max_w)		max_w = w;
		}
		
		SetColumnWidth(col, max_w + 8);
	}
}

//---- Sort Rows ------------------------------------------------------

static
int	sort_sfcs(wxIntPtr udata1, wxIntPtr udata2, wxIntPtr sort_key)
{
	SourceFileClass	*sfc1 = (SourceFileClass*) (udata1);
	SourceFileClass	*sfc2 = (SourceFileClass*) (udata2);
	
	assert(sfc1 && sfc2);
	
	const int	prop_id = abs(sort_key) - 1;
	
	const wxString n1 = sfc1->GetIndexedProperty(prop_id);
	const wxString n2 = sfc2->GetIndexedProperty(prop_id);
	
	return (n1 < n2) * sort_key;
}

//---- On Column Clicked, SORT ----------------------------------------

void	OnColumnClicked(wxListEvent &e)
{
	const int	col = e.GetColumn() + 1;
	
	// if clicked on same column, toggle up & down
	if (abs(m_LastColSort) == abs(col))	m_LastColSort *= -1;
	else					m_LastColSort = col;
	
	uLog(UI, "sort key is %d", m_LastColSort);
	
	// SortItems(sort_sfcs, (wxIntPtr) m_LastColSort);
	
	// is STUCK ?
	// RefreshItems(0, GetItemCount() - 1);
	
	// Refresh();
	e.Skip();
}

//--------------------------------------------------------------------

class ddtLog: public wxLog, public ddtLogSignal

// wx overload
virtual void	DoLogRecord(wxLogLevel lvl, const wxString &msg, const wxLogRecordInfo &info);

// old wx binding
template<UserLogLevel lvl, typename ... Args>
void	uLog(Args ... args)
{
	wxLogGeneric(lvl, args...);
}

	// prevent log from passing messages to inexistant logTextCtrl (will be deleted by call)
	// m_LogChain itself will should be deleted automatically by wx on exit
	// (this remains a leak according to BoundsChecker)
	if (m_LogChain != nil)		m_LogChain->SetLog(nil);

	// (disable built-in, have own version)
	wxLog::SetTimestamp("");
	
	m_LastTimeStamp = wxDateTime::UNow();
	
	// enable ALL levels in wx ...
	wxLog::SetLogLevel(wxLOG_Max - 1);
	
	wxLog::SetActiveTarget(m_PreviousLog);
	m_PreviousLog = nil;

//--------------------------------------------------------------------

	if (!win)	win = FindWindow(TOOL_ID_CONNECTION);
	if (!win)	win = m_ToolBar->FindWindow(TOOL_ID_CONNECTION);
	if (!win)	win = m_ToolBar->FindControl(TOOL_ID_CONNECTION);

//--------------------------------------------------------------------

local fn_s = [[
return function()
	
	local prims = "pirmin"

	a = 15
	print("prims", prims)
	
	_ENV = { _G = _G }

	a = 1
	half_global = 2

	local b0 = a		-- 1
	local b1 = _G.a		-- 15
	
	_G.print("a", a)		-- 1
	_G.print("prims", prims)
end
]]

//---- wxLog IMPLEMENTATION ---------------------------------------------------
	
	// info contains
	//   __FILE__
	//   __LINE__
	//   __FUNCTION__
	//   wx component
	//   threadID
	//   lame timestamp without MILLISECS
	
void	ddtLog::DoLogRecord(wxLogLevel lvl, const wxString &msg, const wxLogRecordInfo &info)
{
	return;		// caca
	
	if (m_LevelSet.count(lvl) == 0)		return;		// level not enabled
	
	wxDateTime	now = wxDateTime::UNow();
	
	int	dsec = (now - m_LastTimeStamp).GetSeconds().GetLo();
	if (dsec > 80)		dsec = 80;
	if (dsec > 1)
	{	// time separator string (dots & LF)
		const wxString	time_sep = wxString('.', dsec);
		
		EmitAll(MSG, time_sep);			// 1) log time separator
	}
	
	m_LastTimeStamp = now;
	
	const wxString	tstamp = wxString::Format(now.Format("%H:%M:%S:%%03d "), (int) now.GetMillisecond());
	
	EmitAll((LogLevel) lvl, tstamp + msg);					// 2) log message itself
	
	const bool	flush_f = (lvl <= wxLOG_Warning);
	
	/*
	// do NOT send to previous log
	if (m_PreviousLog)
	{	// may already be deleted?
		m_PreviousLog->LogRecord(lvl, tstamp + msg, info);
	}
	*/
	
	// immediate flush on important message
	// if (force_flush_f)	Flush();
	
	// do NOT pass on to DoLogTextAtLevel()
}

void	ddtLog::SetPrefixMap(const unordered_map<int, string> &prefixes)
{
	m_LevelPrefixMap.clear();
	
	for (auto const &it : prefixes)
		m_LevelPrefixMap.insert({it.first, it.second});
	
}
	
static const
vector<string>		s_IndentColorWheelNames = {"white", "violet", "salmon", "turquoise", "aquamarine", "blue"};

		m_IndentColorWheel.clear();
		
		wxColourDatabase	*clr_db = wxTheColourDatabase;
		assert(clr_db);
		
		const double	min = 0xe8;
		const double	inv_min = 255 - min;
		
		for (const string &clr_name : s_IndentColorWheelNames)
		{
			wxColour	clr = clr_db->Find(wxString(clr_name));
			if (!clr.IsOk())
			{
				uErr("colour %S failed", clr_name);
				continue;
			}
			
			const double	scale = inv_min / 255.0;
			
			const double	dr = clr.Red() * scale;
			const double	dg = clr.Green() * scale;
			const double	db = clr.Blue() * scale;
			
			m_IndentColorWheel.push_back(wxColour(min + dr, min + dg, min + db));
		}

const wxColour	back_clr {m_IndentColorWheel[indent % m_IndentColorWheel.size()]};

//--------------------------------------------------------------------
	int	icon_id;
	
	if (ce.IsTable())
	{	const bool	expanded_f = ce.IsExpanded();
		
		icon_id = expanded_f ? BITMAP_ID_MINUS : BITMAP_ID_PLUS;
	}
	else	icon_id = BITMAP_ID_EMPTY_PLACEHOLDER;
	
//---- Hit Item ---------------------------------------------------------------
	
class HitItem
{
public:
	// ctors
	HitItem();
	HitItem(const int &row, const int &col, const int &img_id = -1);
	
	void	Defaults(void);
	bool	IsOK(void) const;
	int	Flags(void) const;
	bool	operator==(const HitItem &against) const;
	
	int	m_row, m_col, m_imgID;
};

//--------------------------------------------------------------------

// KEY column
	{
		// indented, decorated key
		const string	indented_key_s = string((size_t) ce.GetIndent() * 2, ' ') + ce.GetDecoratedKey();
		// table branch icon
		const int	icon_id = !ce.IsTable() ? BITMAP_ID_EMPTY_PLACEHOLDER : (ce.IsExpanded() ? BITMAP_ID_MINUS : BITMAP_ID_PLUS);
		
		SetCellData(row, COLUMN_KEY, indented_key_s, VAR_UI_DEFAULT, icon_id);
	}
	
// VALUE string column
	{
		int	ui_id = VAR_UI_DEFAULT;
		string	val_s;
	
		if (ce.IsLuaFileFunction())
		{	// Lua source url
			ui_id = VAR_UI_EDITOR_URL;
			val_s = ce.GetDecoratedVal();
		}
		else if (ce.IsMemoryURL())
		{	// memory url
			ui_id = VAR_UI_MEMORY_URL;
			val_s = xsprintf("[%zu %s]", ce.m_ValS.length(), ce.IsBinaryData() ? "bytes" : "chars");
		}
		else
		{	ui_id = (mask & VAR_FLAG_CHANGED) ? VAR_UI_CHANGED_VAL : VAR_UI_DEFAULT;	// changed (or not)
			val_s = ce.GetDecoratedVal();
		}
		
		SetCellData(row, COLUMN_VAL_STR, val_s, ui_id);
	}
	
// val TYPE
	SetCellData(row, COLUMN_VAL_TYPE, Collected::GetTypeS(ce.GetType()), ce.HasMetatable() ? VAR_UI_METATABLE_URL : VAR_UI_DEFAULT);

// var SCOPE
	if (mask & VAR_FLAG_SHOW_SCOPE)
		SetCellData(row, COLUMN_SCOPE, ce.GetScopeStr(), VAR_UI_DEFAULT);
	
	#if DDT_SHOW_VAR_VIEW_PATH
		// variable path
		SetCellData(row, COLUMN_VAL_PATH, xsprintf("[%d] %s", row, ce.GetPath()), VAR_UI_DEFAULT);
	#endif
}

//---- Hit Item ---------------------------------------------------------------

	HitItem::HitItem()
{
	Defaults();	
}

	HitItem::HitItem(const int &row, const int &col, const int &img_id)
		: m_row(row), m_col(col), m_imgID(img_id)
{
}

void	HitItem::Defaults(void)
{	
	m_row = m_col = m_imgID = -1;
}

bool	HitItem::operator==(const HitItem &vs) const
{	
	return (m_row == vs.m_row) && (m_col == vs.m_col) && (m_imgID == vs.m_imgID);
}

bool	HitItem::IsOK(void) const
{
	return (m_row >= 0) && (m_col >= 0);
}

int	HitItem::Flags(void) const
{
	assert(IsOK());
	return (m_imgID >= 0) ? wxLIST_HITTEST_ONITEMICON : wxLIST_HITTEST_ONITEMLABEL;
}

//---- On Collapse All Tables -------------------------------------------------

void	VarViewCtrl::OnCollapseAllTables(wxCommandEvent &e)
{
	m_ExpandedTablesHashSet.clear();
	
	DoReload();
}

//--------------------------------------------------------------------

void	PrivateList::OnDeleteAllItems(wxListEvent &e)
{
	uLog(LIST_CTRL, "PrivateList::OnDeleteAllItems() topitem %d", GetTopItem());
	
	InitVars();
	
	e.Skip();
}

//--------------------------------------------------------------------

	const size_t	sz = ubuntu_throbber_craw.m_Len;
	
	vector<uint8_t>	buff(sz, 0);
	
	::memcpy(&buff[0], &ubuntu_throbber_craw.m_Data[0], sz);
	
	assert(sz == buff.size());
	
	wxMemoryInputStream	mis(&buff[0], sz);
	
	const int	n_fram = wxImage::GetImageCount(mis, wxBITMAP_TYPE_GIF);
	uMsg("found %d frames in GIF", (int)n_fram);
	
	for (int fram = 0; fram < n_fram; fram++)
	{
		// use new mem instance (or doesn't work)
		wxMemoryInputStream	mis2(&buff[0], sz);
		
		wxImage	img(mis2, wxBITMAP_TYPE_GIF, fram);
		if (!img.IsOk())	break;
		
		wxBitmap	bm(img);
		assert(bm.IsOk());
		
		m_ThrobberBMFrames.push_back(bm);
	}
	
	uMsg("loaded %d frames from GIF", (int)n_fram);
	
	m_BitmapThrobber = new wxStaticBitmap(m_StatusBar, -1/*id*/, m_ThrobberBMFrames[0]);

//---- Get Cycle Factor -------------------------------------------------------

static
int	GetCycle(const double &period_ms, const int &period_int)
{
	using namespace std::chrono;
	
	// get elapsed ms from epoch until now
	const auto	ms = duration_cast<milliseconds>(high_resolution_clock::now().time_since_epoch()).count();
	// get coarse ms
	const auto	coarse_ms = ms / period_ms;
	// get cycle index
	const auto	index = ((int)coarse_ms) % period_int;
	
	return index;
}

//---- Update Throbber --------------------------------------------------------

void	TopFrame::UpdateThrobber(void)
{
	if (!m_StatusBar || (m_ThrobberBMFrames.size() == 0))	return;
	
	const wxSize	sz = m_StatusBar->GetSize();
	
	const int	x = (sz.x - DDT_THROB_ICON_WIDTH);
	const size_t	n_frames = m_ThrobberBMFrames.size();
	
	m_BitmapThrobber->Move(x, 0);
	
	const int	index = GetCycle(500 * n_frames, n_frames);
	assert(index >= 0);
	assert(index < n_frames);
	
	m_BitmapThrobber->SetBitmap(m_ThrobberBMFrames[index]);
}

//---- Draw Cell Overlays (debug) ---------------------------------------------

void	PrivateList::DoDrawCellOverlays(void)
{
	SaveBackGround();
	
	const wxPoint	scrolled = CalcScrolledPosition(wxPoint(0, 0));
	const wxPoint	pos_in_screen = GetScreenPosition();
		
	wxScreenDC	dc;
	
	wxScreenDC::StartDrawingOnTop(this);
	
	wxPen	red_pen(wxColour(0xff, 0, 0, 0), 1, wxPENSTYLE_SOLID);
	wxPen	green_pen(wxColour(0, 0xff, 0, 0), 1, wxPENSTYLE_SOLID);
	wxBrush	no_brush(wxColor(0, 0, 0, 0), wxBRUSHSTYLE_TRANSPARENT);
	
	dc.SetPen(red_pen);
	dc.SetBrush(no_brush);
	
	dc.SetDeviceOrigin(pos_in_screen.x, pos_in_screen.y + m_HeaderHeight);
		
	for (const auto &it : m_RowToColMap)
	{
		const int		row = it.first;
		const vector<HotRect>	&rect_list = it.second;
		
		// scan columns
		for (const HotRect &hr : rect_list)
		{
			/*
			Rect	paint_rc = hr.m_rect;
			paint_rc.Offset(scrolled);
			
			dc.SetPen(hr.IsIcon() ? green_pen : red_pen);
			
			dc.DrawRectangle(paint_rc);
			*/
		}
	}
	
	wxScreenDC::EndDrawingOnTop();
	
	// RestoreBackGround();
}

//---- Save Background --------------------------------------------------------

void	PrivateList::SaveBackGround(void)
{
	const wxRect	rc = GetScreenRect();
	const wxPoint	pt {rc.x, rc.y};
	const wxSize	sz {rc.width, rc.height};
	
	wxBitmap	bm(sz);

	wxMemoryDC	mdc;
	
	mdc.SelectObject(bm);
	
	wxScreenDC	screen_dc;
	
	// (hide cursor)
	wxSetCursor(wxNullCursor);
	
	mdc.Blit(wxPoint(), sz, &screen_dc, pt);
	mdc.SelectObject(wxNullBitmap);
	
	// restore cursor
	wxSetCursor(*wxSTANDARD_CURSOR);
	
	m_BitmapCopy = bm;
}

//---- Restore Background -----------------------------------------------------

void	PrivateList::RestoreBackGround(void)
{
	const wxRect	rc = GetScreenRect();
	const wxPoint	pt {rc.x, rc.y};
	const wxSize	sz {rc.width, rc.height};
	
	wxMemoryDC	mdc;
	
	mdc.SelectObject(m_BitmapCopy);
	
	wxScreenDC	screen_dc;
	
	screen_dc.Blit(pt, sz, &mdc, wxPoint());
	
	mdc.SelectObject(wxNullBitmap);
}

//--------------------------------------------------------------------

struct HotRect
{
	// ctor
	HotRect(const int &row, const int &col, const HIT_TYPE &typ, const wxRect &rc)
		: m_row(row), m_col(col), m_type(typ), m_rect(rc)
	{
	}
	
	bool	IsIcon(void) const	{return (m_type == HIT_TYPE::ICON);}
		
	int		m_row, m_col;
	HIT_TYPE	m_type;
	wxRect		m_rect;	
};

//---- Update Virtual Width ---------------------------------------------------			// why specific to HORIZ ???

void	virtScrollBar::UpdateVirtualWidth(void)
{
	const int	current_virtual_width = wxScrollBar::GetRange();
	
	if (!Reload())		return;
	assert(IsH());
	
	const bool	virt_changed_f = (current_virtual_width != m_Info.m_VirtualSize);
	
	const bool	scroll_vis_f = IsScrollEnabled();
	
	uLog(SCROLL, "UpdateVirtualWidth(changed %c, vis %d, virtual %d, shown %c)", virt_changed_f, m_Info.m_VisSize, m_Info.m_VirtualSize, scroll_vis_f);
	
	// "sets properties of a BUILT-IN scrollbar" ???
	// wxScrollBar::SetScrollbar(	scroll_vis_f ? wxScrollBar::GetThumbPosition() : 0,	// set to zero if hidden
	wxScrollBar::SetScrollbar(	scroll_vis_f ? m_Info.m_LastPos : 0,			// set to zero if hidden
					m_Info.m_VisSize,					// thumb size
					m_Info.m_VirtualSize,
					m_Info.m_VisSize,					// page jump size
					true);							// refresh -- IGNORED in Gtk implementation
	
	m_Owner.SetVirtScrollbarVisible(IsV(), scroll_vis_f);
	
	// if (IsShown() != scroll_vis_f)	Show(scroll_vis_f);
	Show(scroll_vis_f);									// toggle scrollbar on/off
	
	// can get STUCK on old pos
	uLog(SCROLL, "  last thumb %d VS pos %d", wxScrollBar::GetThumbPosition(), m_Info.m_LastPos);
}

//---- Init wxListCtrl Patch Renderer -----------------------------------------

void	TopFrame::InitListPatchRenderer(void)
{
	m_ListPatchRenderer = new ListPatchRenderer(&m_AuxBitmaps);
	
	ListPatchRenderer	&rend = *m_ListPatchRenderer;
	
	rend.CreateFont(VAR_UI_COLUMN_HEADER, "sans", 11, Color(20, 20, 20), FONT_STYLE_NONE);
	rend.CreateFont(VAR_UI_DEFAULT, "monospace", 9, Color(10, 10, 10), FONT_STYLE_NONE);			// normal (black)
	rend.CreateFont(VAR_UI_CHANGED_VAL, "monospace", 9, Color(255, 10, 10), FONT_STYLE_NONE);		// changed var (red)
	rend.CreateFont(VAR_UI_EDITOR_URL, "monospace", 9, Color(10, 10, 255), FONT_STYLE_UNDERLINED);		// editor url (blue)
	rend.CreateFont(VAR_UI_MEMORY_URL, "monospace", 9, Color(10, 120, 10), FONT_STYLE_UNDERLINED);		// memory url (dark green)
	rend.CreateFont(VAR_UI_METATABLE_URL, "monospace", 9, Color(10, 10, 255), FONT_STYLE_UNDERLINED);	// metatable url (blue)
}

//---- Get Cell Data Pointer --------------------------------------------------

const CellData*	VarViewCtrl::GetCellDataPtr(const int &row, const int &col)
{
	// used by wxListPatch
	uLog(LIST_CTRL, "VarViewCtrl::GetCellDataPtr(%d, %d)", row, col);
	
	assert(row < m_CollectedList.size());
	const Collected	&ce = m_CollectedList[row];
	
	// generated on the fly
	const bool	ok = ToCellData(row, col, ce, m_ShowScopeFlag ? VAR_FLAG_SHOW_SCOPE : 0, m_DummyCellData/*&*/);
	if (!ok)	return nil;		// no data
	
	return &m_DummyCellData;
}

//---- Immediate Refresh ------------------------------------------------------

Grid&	Grid::ImmediateRefresh(void)
{
	try
	{	
		const bool	ok = PrepareOffScreenBitmap();
		if (!ok)	return *this;
		
		assert(HasRenderContext());
		
		ApplyCellData();
		RenderToBitmap(GetRenderContext());
		RenderHotmaps(GetRenderContext());
		BlitOffScreen_IMP();
	}
	catch (...)
	{
		uMsg("EXCEPTION ERROR in RenderToBitmap()");
		
		// re-throw
		throw;
	}
	
	return *this;
}

//---- Prepare Offscreen Bitmap -----------------------------------------------

bool	Grid::PrepareOffScreenBitmap(void)
{
	const bool	ok = PrepareRenderContext_IMP();
	return ok;
}

//---- Request Refresh --------------------------------------------------------

void	Grid::RequestRefresh(void)
{
	RequestRefresh_IMP();
}

//---- On List Item Clicked ---------------------------------------------------

void	VarViewCtrl::OnListItemEditEnd(GridEvent &e)
{
	assert(m_ListCtrl);
	assert(m_WatchBag);
	
	auto	&grid = m_ListCtrl->GetGrid();

	// wash away edit ctrl
	grid.OnImmediateRefresh();
		
	if (!e.IsEditOK())	return;			// was canceled
	
	const int	row = e.GetIndex();
	const string	name = e.GetString();
	
	// if is last item
	if (row == m_UsedCnt)
	{	// add watch
		m_WatchBag->Add(name);
	}
	else
	{	// else edited or remove existing watch
		assert(row < m_CollectedList.size());
		const Collected	&ce = m_CollectedList[row];
		
		assert(ce.GetIndent() == 0);
		
		m_WatchBag->Edit(ce.GetKey(), name);
	}
	
	DoReload();
}

//---- Scrub To Ratio ------------------------------------------------

void	SourceFileClass::ScrubToRatio(const double &ratio)
{
	assert(m_EditorCtrl);
	
	const stcPos	cpos = GetStcPosition();
	
	const int	ln = cpos.TotalLines() * ratio;
	
	// m_EditorCtrl->LineScroll(0, ln);
	m_EditorCtrl->ScrollToLine(ln);
}

class BannerFrame : public wxFrame
{
public:
	// ctor
	BannerFrame(TopFrame *parent, int id)
		: wxFrame(parent, id, "", wxDefaultPosition, wxDefaultSize, wxSTAY_ON_TOP | wxFRAME_NO_TASKBAR | wxFRAME_NO_WINDOW_MENU | wxBORDER_NONE)
	{
		assert(parent);
		m_TopFrame = parent;
		
		m_BannerWindow = new wxBannerWindow(this, wxTOP);
		m_BannerWindow->SetId(WINDOW_ID_BANNER);
		
		wxBoxSizer	*v_sizer = new wxBoxSizer(wxVERTICAL);
		v_sizer->Add(m_BannerWindow, wxSizerFlags(1).Expand());
		SetSizerAndFit(v_sizer);
		
		m_BannerTimer.SetOwner(this, TIMER_ID_BANNER);		// (apparently not redundant)
		
		Bind(wxEVT_TIMER, &BannerFrame::OnTimerNotify, this, TIMER_ID_BANNER);
		
		SetTransparent(0x80);
		
		Hide();
	}
	// dtor
	virtual ~BannerFrame()
	{
		m_BannerTimer.Stop();
		Unbind(wxEVT_TIMER, &BannerFrame::OnTimerNotify, this);
	}
	
	void	SetBannerText(const wxString &msg)
	{
		uMsg("BannerFrame::SetBannerText(%S)", msg);
		assert(m_TopFrame && !m_TopFrame->ExitFlag());
		assert(m_BannerWindow);
		
		// align banner frame over TopFrame
		wxRect	rc = m_TopFrame->GetRect();
		rc.height = rc.height / 5;
		SetSize(rc);
			
		m_BannerWindow->SetText("Banner", msg);
		
		uLog(TIMER, "BannerFrame::SetBannerText() start m_BannerTimer");
		m_BannerTimer.Start(BANNER_TIMEOUT_MS, wxTIMER_ONE_SHOT);
		Show();
	}
	
	void	OnTimerNotify(wxTimerEvent &e)
	{
		uLog(TIMER, "BannerFrame::OnTimerNotify()");
		assert(m_TopFrame && !m_TopFrame->ExitFlag());
		assert(m_BannerWindow);
		
		m_BannerTimer.Stop();
		Hide();
	}
	
private:
	
	TopFrame	*m_TopFrame;
	wxBannerWindow	*m_BannerWindow;
	wxTimer		m_BannerTimer;
};

//---- Dispatch Function Bookmarks --------------------------------------------

void	TopNotebookImp::DispatchFunctionBookmarks(const CollectedList &coll_list)
{
	// clear all
	for (SourceFileClass *sfc : m_Controller.GetSFCInstances())	sfc->m_SourceBookmarks.clear();
	
	// dispatch
	for (const Collected &ce : coll_list)
	{
		const string	func_name {ce.GetKey()};
		const string	short_filename {ce.GetVal()};
		
		int	first_ln, last_ln;
		bool	ok = ce.GetFunctionLineRange(first_ln/*&*/, last_ln/*&*/);
		assert(ok);
		
		SourceFileClass	*sfc = m_Controller.GetSFC(short_filename);
		assert(sfc);
		
		sfc->m_SourceBookmarks.push_back({func_name, first_ln, last_ln});
	}
	
	// notify current SFC
	SearchBar	*search_bar = m_TopNotePanel.GetSearchBar();
	assert(search_bar);
		
	wxThreadEvent	e(wxEVT_THREAD, BROADCAST_ID_SELECTED_SFC);
		
	wxQueueEvent(search_bar, e.Clone());
}

//--------------------------------------------------------------------

	EVT_COMMAND_SCROLL(	CONTROL_ID_MEMORY_SCROLL_BAR,		MemoryViewCtrl::OnVirtualScrollEvent)
	EVT_MOUSEWHEEL(							MemoryViewCtrl::OnMouseWheel)

	const int	hex_w = m_CharPixels.x * ((m_BytesPerLine * 3) + 16);		// RECALC w/out hardcoded address width
	const int	ascii_w = m_CharPixels.x * (m_BytesPerLine + 3);
	
	m_HexCtrl = new wxTextCtrl(this, CONTROL_ID_MEMORY_HEX_TEXT, "", wxDefaultPosition, wxSize(hex_w, -1), wxTE_RICH | wxTE_READONLY | wxTE_MULTILINE | wxTE_NO_VSCROLL);
	m_HexCtrl->SetDefaultStyle(m_ColorLUT[0]);
	
	m_AsciiSideCtrl = new wxTextCtrl(this, CONTROL_ID_MEMORY_ASCII_SIDE_TEXT, "", wxDefaultPosition, wxSize(ascii_w, -1), wxTE_RICH | wxTE_READONLY | wxTE_MULTILINE | wxTE_NO_VSCROLL);
	m_AsciiSideCtrl->SetDefaultStyle(m_ColorLUT[0]);
	
	m_FullAscii = new wxTextCtrl(this, CONTROL_ID_MEMORY_ASCII_FULL_TEXT, "", wxDefaultPosition, wxDefaultSize, wxTE_RICH | wxTE_READONLY | wxTE_MULTILINE | wxTE_NO_VSCROLL);
	m_FullAscii->SetDefaultStyle(m_ColorLUT[0]);
	
	m_VirtScrollBar = new wxScrollBar(this, CONTROL_ID_MEMORY_SCROLL_BAR, wxDefaultPosition, wxDefaultSize, wxSB_VERTICAL);
	*/
	
	/*
	// views + scrollbar
	m_HSizer = new wxBoxSizer(wxHORIZONTAL);
	
		// view 1 (canonical)
		m_HSizer->Add(m_HexCtrl, wxSizerFlags(0).Border(wxTOP | wxBOTTOM, 2).Expand());
		m_HSizer->Add(m_AsciiSideCtrl, wxSizerFlags(0).Border(wxTOP | wxBOTTOM, 2).Expand());
		m_HSizer->AddStretchSpacer();
	
		// view 2 (full ASCII)
		m_HSizer->Add(m_FullAscii, wxSizerFlags(1).Border(wxTOP | wxBOTTOM, 2).Expand());
	
	m_HSizer->Add(m_VirtScrollBar, wxSizerFlags(0).Border(wxALL, 2).Expand());

//---- Fit Scrollbar after data was dumped ------------------------------------

void	MemoryViewCtrl::FitScrollbar(void)
{
	assert(m_VirtScrollBar);
	assert(m_HexCtrl);
	assert(m_FullAscii);
	
	const wxTextCtrl	*src_ctl = m_ToggleFlag ? m_HexCtrl : m_FullAscii;
	
	const int	client_h = src_ctl->GetClientSize().GetHeight();
	const int	n_total_lines = src_ctl->GetValue().Freq('\n');	// src_ctl->GetNumberOfLines();
	if ((client_h > 0) && (n_total_lines > 0))
	{	const int	thumb_sz = client_h;
		const int	range_sz = n_total_lines * m_CharPixels.y;
		const int	page_sz = client_h * 0.9;
		
		m_VirtScrollBar->SetScrollbar(0, thumb_sz, range_sz + thumb_sz, page_sz);
	}
	else
	{	
		m_VirtScrollBar->SetScrollbar(0, 0, 0, 0);
	}	
}

//---- On Scroll event --------------------------------------------------------

void	MemoryViewCtrl::OnVirtualScrollEvent(wxScrollEvent &e)
{
	assert(m_HexCtrl);
	assert(m_AsciiSideCtrl);
	assert(m_FullAscii);
	
	const int	y_scroll = e.GetPosition();
	
	m_HexCtrl->SetScrollPos(wxSB_VERTICAL, y_scroll);
	m_AsciiSideCtrl->SetScrollPos(wxSB_VERTICAL, y_scroll);
	m_FullAscii->SetScrollPos(wxSB_VERTICAL, y_scroll);
	
	e.Skip();
}

//---- On Mouse Wheel event ---------------------------------------------------

void	MemoryViewCtrl::OnMouseWheel(wxMouseEvent &e)
{
	assert(m_VirtScrollBar);
	assert(m_HexCtrl);
	assert(m_AsciiSideCtrl);
	assert(m_FullAscii);
	
	const int	wheel_delta = e.GetWheelDelta() / 4;
	const int	wheel_rot = e.GetWheelRotation();
	
	int		delta = 0;
	
	if (wheel_rot < -wheel_delta)		delta = 1;
	else if (wheel_rot > wheel_delta)	delta = -1;
	else
	{	e.Skip();
		return;
	}
	
	const int	pos = m_VirtScrollBar->GetThumbPosition() + (m_VirtScrollBar->GetPageSize() * delta);
	
	m_VirtScrollBar->SetThumbPosition(pos);
	
	m_HexCtrl->SetScrollPos(wxSB_VERTICAL, pos);
	m_AsciiSideCtrl->SetScrollPos(wxSB_VERTICAL, pos);
	m_FullAscii->SetScrollPos(wxSB_VERTICAL, pos);
}

//--------------------------------------------------------------------

	assert(m_HexCtrl);
	assert(m_AsciiSideCtrl);
	assert(m_FullAscii);
	
	m_HSizer->Show(m_HexCtrl, m_ToggleFlag);
	m_HSizer->Show(m_AsciiSideCtrl, m_ToggleFlag);
	m_HSizer->Show((size_t)2, m_ToggleFlag);		// (stretch sizer)
	m_HSizer->Show(m_FullAscii, !m_ToggleFlag);
	
	m_HSizer->Layout();
	
	FitScrollbar();

//--------------------------------------------------------------------

	// wxBoxSizer		*m_HSizer;
	// wxTextCtrl		*m_HexDumpCtrl, *m_AsciiSideCtrl, *m_FullAscii;
	// wxScrollBar		*m_VirtScrollBar;

//---- PERFECT span algo ---------------------------------------------

	{
		const vector<int>	test {0, 8, 22, 23, 24, 5}; 
		
		vector<pair<int, int>>	spans;
		
		for (const auto &pos : test)
		{
			if ((spans.size() && (pos == spans.back().second)))
				spans.back().second++;
			else	spans.push_back({pos, pos + 1});
		}
		
		stringstream	ss;
		
		for (const auto &elm : spans)
		{
			ss << xsprintf("[%d; %d] ", elm.first, elm.second);
		}
		
		const string	s = ss.str();
		
		uMsg("spans: %s", s);
		
		// pop first
		// spans.pop_front();
	}

//--------------------------------------------------------------------

bool	Collected::GetFunctionLineRange(int &start, int &end) const
{
	start = end = -1;
	if ((m_Type != CTYPE_LUA_FUNCTION) && (m_Type != CTYPE_LUA_STRING_FUNCTION))	return false;
	
	start = m_LineStart;
	end = m_LineEnd;
	
	return true;
}

	case DAEMON_MSG::REPLY_GLOBAL_FUNCTIONS:
	{
		assert(m_TopNotePanel);
		
		requester_id = (VAR_SOLVE_REQUESTER) mis.Read32();
		assert(requester_id == SOLVE_REQUESTER_FUNCTIONS);
		
		CollectedList	collist{mis};
		
		uMsg("REPLY_GLOBAL_FUNCTIONS got %zu functions", collist.size());
		
		m_TopNotePanel->DispatchFunctionBookmarks(collist);
		
		/*
		{
			ResumeVM		resume_msg(CLIENT_CMD::RUN);
			MemoryOutputStream	mos;

			mos << CLIENT_MSG::REQUEST_VM_RESUME << resume_msg;
			m_Client->SendMessage(mos);
		}
		*/
	}	break;
		
//---- Update Lua Functions ---------------------------------------------------

	// sfc may be nil
	
void	SearchBar::UpdateLuaFunctions(const SourceFileClass *sfc, const bool alpha_sort_f)
{
	// uMsg("SearchBar::UpdateLuaFunctions()");
	
	if (!sfc)		return;					// no selected SFC
	
	// get bookmarks
	m_FunctionBookmarks = sfc->GetSortedFunctionBookmarks(alpha_sort_f/*alpha or line sort*/);
	
	wxArrayString	items;
	
	for (const auto &it : m_FunctionBookmarks)	items.Add(wxString{it.Name()});
	
	m_FunctionsDropDown->Append(items);
	// m_FunctionsDropDown->Refresh();		// (not needed)
}

//---- On Function Drop-Down Menu event ---------------------------------------

void	SearchBar::OnFunctionDropDownEvent(wxCommandEvent &e)
{
	// won't get here if combo selection is unchanged, but will lose focus!
	
	const int	index = e.GetInt();
	// uMsg("SearchBar::OnFunctionDropDownEvent(index %d)", index);
	
	// (so stays in dropdown)
	e.Skip();
	
	SourceFileClass	*sfc = m_TopNotebookImp.GetSelectedSFC();
	if (!sfc)	return;				// no selected SFC, should be error?
	
	assert((index >= 0) && (index < m_FunctionBookmarks.size()));
	const SourceBookmark	&bm = m_FunctionBookmarks[index];
	
	// uMsg("  goto function %S @ ln %d", bm.Name(), bm.FirstLine());
	
	sfc->ShowLine(bm.FirstLine(), true/*center*/);
	sfc->SetFocus();
}

//---- Update Lua Functions ---------------------------------------------------

	// sfc may be nil
	
void	SearchBar::UpdateLuaFunctions(const SourceFileClass *sfc, const bool alpha_sort_f)
{
	// uMsg("SearchBar::UpdateLuaFunctions()");
	
	if (!sfc)		return;					// no selected SFC
	
	// get bookmarks
	m_FunctionBookmarks = sfc->GetSortedFunctionBookmarks(alpha_sort_f/*alpha or line sort*/);
	
	wxArrayString	items;
	
	for (const auto &it : m_FunctionBookmarks)	items.Add(wxString{it.Name()});
	
	m_FunctionsDropDown->Append(items);
	// m_FunctionsDropDown->Refresh();		// (not needed)
}

//---- On Function Drop-Down Menu event ---------------------------------------

void	SearchBar::OnFunctionDropDownEvent(wxCommandEvent &e)
{
	// won't get here if combo selection is unchanged, but will lose focus!
	
	const int	index = e.GetInt();
	// uMsg("SearchBar::OnFunctionDropDownEvent(index %d)", index);
	
	// (so stays in dropdown)
	e.Skip();
	
	SourceFileClass	*sfc = m_TopNotebookImp.GetSelectedSFC();
	if (!sfc)	return;				// no selected SFC, should be error?
	
	assert((index >= 0) && (index < m_FunctionBookmarks.size()));
	const SourceBookmark	&bm = m_FunctionBookmarks[index];
	
	// uMsg("  goto function %S @ ln %d", bm.Name(), bm.FirstLine());
	
	sfc->ShowLine(bm.FirstLine(), true/*center*/);
	sfc->SetFocus();
}

//--------------------------------------------------------------------

	const size_t	len = m_CharStylBuff.size();
	StringSet	sset;
	
	uLog(LEX, "REPARSE %d chars", len);
	
	string	last_identifier, last_fn;
	bool	hit_fn_f = false;
	
	for (int i = 0; i < len; i++)
	{
		if (LUA_LEX_IDENTIFIER == m_CharStylBuff[i].m_styl)
		{
			string	s;
		
			while ((LUA_LEX_IDENTIFIER == m_CharStylBuff[i].m_styl) && (i < len))	s.push_back(m_CharStylBuff[i++].m_char);
			
			i--;
			
			if (hit_fn_f)
				uLog(LEX, "  FUNCTION %S", s);
				
			hit_fn_f = false;
			last_identifier = s;
		}
		
		if (LUA_LEX_WORD == m_CharStylBuff[i].m_styl)
		{
			string	s;
		
			while ((LUA_LEX_WORD == m_CharStylBuff[i].m_styl) && (i < len))
			{
				s.push_back(m_CharStylBuff[i++].m_char);
			}
			
			i--;
			
			if (s == "function")
			{
				// uLog(LEX, "last %S, FUNCTION()", last_identifier);
				hit_fn_f = true;
				last_fn = last_identifier;
			}
			else
			{	if (hit_fn_f)
				{
					uLog(LEX, "  CANCELED %s", last_fn);
				}
				
				hit_fn_f = false;
			}
		}
	}
	
	StringList	slist = sset.ToStringList();
	slist.Sort();
	
	const string	s = slist.ToFlatString("\n");
	
	// uLog(STC_FUNCTION, "LUA_IDS %s", s);

//--------------------------------------------------------------------

static const
unordered_map<int, string>	s_LuaStyleLUT
{
	{wxSTC_LUA_DEFAULT,		"default"},
	{wxSTC_LUA_COMMENT,		"comment"},
	{wxSTC_LUA_COMMENTLINE,		"commentline"},
	{wxSTC_LUA_COMMENTDOC,		"commentdoc"},
	{wxSTC_LUA_NUMBER,		"number"},
	{wxSTC_LUA_WORD,		"word"},			// word group 0 (enum 5)
	{wxSTC_LUA_STRING,		"string"},
	{wxSTC_LUA_CHARACTER,		"character"},
	{wxSTC_LUA_LITERALSTRING,	"litteralstring"},
	{wxSTC_LUA_PREPROCESSOR,	"preprocessor"},
	{wxSTC_LUA_OPERATOR,		"operator"},
	{wxSTC_LUA_IDENTIFIER,		"identifier"},			// Lua variable (enum 11)
	{wxSTC_LUA_STRINGEOL,		"stringeol"},
	{wxSTC_LUA_WORD2,		"word2"},
	{wxSTC_LUA_WORD3,		"word3"},
	{wxSTC_LUA_WORD4,		"word4"},
	{wxSTC_LUA_WORD5,		"word5"},
	{wxSTC_LUA_WORD6,		"word6"},
	{wxSTC_LUA_WORD7,		"word7"},
	{wxSTC_LUA_WORD8,		"word8"},
	{wxSTC_LUA_LABEL,		"label"}
};

enum RGB_COLOR : uint32_t
{
        BLACK		= 0x000000FFul,
        ORANGE		= 0xF0B000FFul,
        RED		= 0xFF0000FFul,
        DARK_RED	= 0xC00000FFul,
        DARK_GREY	= 0x404040FFul,
        GREY		= 0x808080FFul,
        YELLOW		= 0xF0C000FFul,
	STRONG_YELLOW	= 0xFFF050FFul,			// 255, 240,  80

        CYAN		= 0x00A0A0FFul,
        GREEN		= 0x00FF00FFul,
        DARK_GREEN	= 0x00A000FFul,
        LIGHT_GREEN	= 0x80FF80FFul,
        BLUE		= 0x0000FFFFul,
        DARK_BLUE	= 0x0000C0FFul,
        LIGHT_BLUE	= 0x8080FFFFul,
        PALE_BLUE	= 0x3686C9FFul,
        PURPLE		= 0xFF00E7FFul,
	DARK_PURPLE	= 0x800080FFul,
	PINK		= 0xFF92E0FFul,
	KAKI		= 0x99C700FFul,
	BROWN		= 0xC75D00FFul,
	DARK_BROWN	= 0x632E00FFul
};

//==== DIR MAP ================================================================

	DirMap::DirMap()
{	
	m_ClientDir.clear();
	m_SymName.clear();
	m_Index = -1;		// [unassigned]
}

	DirMap::DirMap(const wxString &client_dir, const wxString &sym_name)
		: DirMap()
{
	m_ClientDir = client_dir;
	m_SymName = sym_name;
}

bool	DirMap::IsOk(void) const
{
	return !m_ClientDir.empty() && !m_SymName.empty();
}

wxString	DirMap::GetClientDir(void) const
{
	return m_ClientDir;
}

wxString	DirMap::GetMapName(void) const
{
	return m_SymName;
}

//---- Delete Unused DirMaps --------------------------------------------------

void	Controller::DeleteUnusedDirMaps(void)
{
	if (m_SourceFileLUT.size() == 0)			return;		// need all SFCs
	
	// count used maps
	unordered_set<string>	used_map_set;
	
	for (const auto &it : m_SourceFileLUT)
	{
		const SourceFileClass *sfc = it.second;
		assert(sfc);
		
		const string	map_name = sfc->GetDirMapName().ToStdString();
		assert(!map_name.empty());
		
		used_map_set.insert(map_name);
	}
	
	int	n_maps_deleted = 0;
	
reloop:
	
	// delete unused maps
	for (int i = 0; i < m_DirMapList.size(); i++)
	{
		const DirMap	&dm = m_DirMapList[i];
		const string	map_name = dm.GetMapName().ToStdString();
		
		if (used_map_set.count(map_name) > 0)		continue;	// skip used
		
		// unused, delete & reloop
		m_DirMapList.erase(m_DirMapList.begin() + i);
		n_maps_deleted++;
		goto reloop;
	}
	
	uLog(LOGIC, "Controller::DeleteUnusedDirMaps() deleted %d maps", n_maps_deleted);
}

//---- Re-Index DirMaps name -> index -----------------------------------------

void	Controller::ReindexDirMaps(void)
{
	m_MapNameToIndex.clear();
	m_MapClientPathToIndex.clear();
	
	for (int i = 0; i < m_DirMapList.size(); i++)
	{
		DirMap		&dm = m_DirMapList[i];
		
		const string	map_name = dm.GetMapName().ToStdString();
		const string	client_path = dm.GetClientDir().ToStdString();
		
		// make sure are no duplicates
		assert(m_MapNameToIndex.count(map_name) == 0);
		assert(m_MapClientPathToIndex.count(client_path) == 0);
		
		m_MapClientPathToIndex.insert({client_path, i});
		m_MapNameToIndex.insert({map_name, i});
		
		// update index
		dm.m_Index = i;
	}
}

//---- Get Map Name from Map Path ---------------------------------------------

wxString	Controller::GetMapNameFromDir(const wxString &map_dir) const
{
	if (map_dir.empty())		return wxEmptyString;
	if (map_dir == "/")		return wxEmptyString;
	
	const int	n_seps = map_dir.Freq('/');
	if (n_seps == 0)		return map_dir;			// already in map Name format
	assert(n_seps == 1);						// shouldn't have more than 1 separator (for now)
	
	const wxString	map_name = map_dir.AfterLast('/');
	return map_name;
	
	return map_dir;
}

//---- Get Map Index from Symbolic Name ---------------------------------------

// private
int	Controller::GetMapIndexFromMapName(const wxString &map_name) const
{
	const string	sanitized_map_name = GetMapNameFromDir(map_name).ToStdString();
	if (sanitized_map_name.empty())		return -1;		// not found
	
	const auto it = m_MapNameToIndex.find(sanitized_map_name);
	if (it == m_MapNameToIndex.end())	return -1;		// not found
	
	return it->second;
}

//---- Has (existing) Map ? ---------------------------------------------------

bool	Controller::HasClientMap(const wxString &client_fullpath) const
{
	const string	client_dir = GetFileDir(client_fullpath).ToStdString();
	
	return (m_MapClientPathToIndex.count(client_dir) > 0);
}

//---- Has existing symbolic Map ? --------------------------------------------

bool	Controller::HasSymMap(const wxString &sym_name) const
{
	return (m_MapNameToIndex.count(sym_name.ToStdString()) > 0);
}

//---- Get (indexed) Map ------------------------------------------------------

DirMap	Controller::GetMap(const int &index) const
{
	assert((index >= 0) && (index <= m_DirMapList.size()));
	
	return m_DirMapList.at(index);
}

//---- Convert LuaMap-space to Client-space short name ------------------------

string	Controller::MappedFileToClientShortName(const string &lua_fullpath) const
{
	assert(!lua_fullpath.empty());
	
	const auto	split = FileName::SplitUnixPath(lua_fullpath);
	assert(split);
	assert(!split.GetFullName().empty());
	
	return split.GetFullName();
}

//---- Get SFCs in given DirMap -----------------------------------------------

vector<SourceFileClass*>	Controller::GetDirMapSFCs(const string &map_name) const
{
	vector<SourceFileClass*>	sfc_list;
	
	for (const auto it : m_SourceFileLUT)
	{
		SourceFileClass	*sfc = it.second;
		assert(sfc);
		
		if (sfc->GetDirMapName() != map_name)		continue;
		
		sfc_list.push_back(sfc);
	}
	
	return sfc_list;
}

//---- Get Filenames in given DirMap (name key) -------------------------------

StringList	Controller::GetDirMapFiles(const std::string &map_name) const
{
	const vector<SourceFileClass*>	sfc_list = GetDirMapSFCs(map_name);
	
	StringList	filenames;
	
	for (const auto sfc : sfc_list)
	{
		filenames.push_back(sfc->GetShortName().ToStdString());
	}
	
	return filenames;
}

//---- Get Highest (auto-map) Index -------------------------------------------

int	Controller::GetHighestAutoMapIndex(const wxString &base_map_name) const
{
	int	max_index = 0;
	
	for (auto it : m_DirMapList)
	{
		wxString	remain;
		
		if (!it.GetMapName().StartsWith(base_map_name, &remain))	continue;
		
		long	ind = -1;
		
		if (!remain.ToLong(&ind))		continue;
		if (ind > max_index)			max_index = ind;
	}
	
	return max_index;
}

//---- Add New Map ------------------------------------------------------------

DirMap	Controller::NewMap(const wxString &client_fullpath, const wxString &map_name)
{
	const wxString	client_dir = GetFileDir(client_fullpath);
	
	// const int	index = m_DirMapList.size();
	
	if (map_name.IsEmpty())
	{	// auto-map name
		int	last_ind = GetHighestAutoMapIndex("map");
		
		m_DirMapList.push_back(DirMap(client_dir, wxString::Format("map%03d", last_ind + 1)));
	}
	else
	{	if (HasSymMap(map_name))
		{	// duplicate map REFUSED
			return DirMap();
		}
		
		m_DirMapList.push_back(DirMap(client_dir, map_name));
	}
	
	SetDirtyProject();
	
	return m_DirMapList.back();
}

//---- Get New or Existing Map ------------------------------------------------

DirMap	Controller::NewOrExistingMap(const wxString &client_fullpath, const wxString &map_name)
{
	assert(map_name != "/");		// doesn't currently handle map PATHs
	const wxString	client_dir = GetFileDir(client_fullpath);
	
	const DirMap	dm = GetMapFromClientDir(client_dir);
	if (dm.IsOk())		return dm;	// return existing
	
	// instantiate new
	const DirMap	new_dm = NewMap(client_dir, map_name);
	assert(new_dm.IsOk());
	
	return new_dm;
}

//---- Delete Map -------------------------------------------------------------

bool	Controller::DeleteMap(const wxString &map_name)
{
	// re-index
	ReindexDirMaps();
	
	const int	index = GetMapIndexFromMapName(map_name);
	if (index == -1)						return false;	// map not found
	
	// make sure map is empty
	if (GetDirMapSFCs(map_name.ToStdString()).size() > 0)		return false;	// map wasn't empty
	
	m_DirMapList.erase(m_DirMapList.begin() + index);
	
	// dirty prefs
	SetDirtyProject();
	
	return true;
}

//---- Rename Mapping ---------------------------------------------------------

bool	Controller::RenameMapping(const wxString &old_map_name, const wxString &new_map_name)
{
	if (old_map_name == new_map_name)		return true;		// silent return on same names
	if (HasSymMap(new_map_name))			return false;		// duplicate map REFUSED
	
	const int	index = GetMapIndexFromMapName(old_map_name);
	if (index < 0)					return false;		// existing map NOT FOUND
	
	// rename SFCs in this map
	vector<SourceFileClass*>	sfc_list = GetDirMapSFCs(old_map_name.ToStdString());
	
	for (const auto sfc : sfc_list)
	{
		sfc->SetDirMapName(new_map_name);
	}
	
	m_DirMapList[index].m_SymName = new_map_name;
	
	// dirty prefs
	SetDirtyProject();
	
	return true;		// ok
}

//---- Get Map from Symbolic Name ---------------------------------------------

DirMap	Controller::GetMapFromMapName(const wxString &map_name) const
{
	const int	index = GetMapIndexFromMapName(map_name);
	if (index == -1)			return DirMap();	// not found
	
	return m_DirMapList.at(index);
}

//---- Get Map from Client Dir ------------------------------------------------

DirMap	Controller::GetMapFromClientDir(const wxString &client_dir) const
{
	const auto it = m_MapClientPathToIndex.find(client_dir.ToStdString());
	if (it == m_MapClientPathToIndex.end())	return DirMap();	// not found
	
	return m_DirMapList.at(it->second);
}

//---- Get Serialized DirMaps (for prefs) -------------------------------------

StringList	Controller::GetSerializedDirMaps(void) const
{
	StringList	flat_strings;
	
	for (auto map_entry : m_DirMapList)
	{
		flat_strings.push_back(map_entry.GetClientDir().ToStdString());
		flat_strings.push_back(map_entry.GetMapName().ToStdString());
	}
	
	return flat_strings;
}

//---- Get DirMap List --------------------------------------------------------

vector<DirMap>	Controller::GetMapList(void) const
{	
	return m_DirMapList;
}

//---- Get DirMap-relative SFC Names (for prefs) ------------------------------

StringList	Controller::GetDirMapRelativeSFCNames(void) const
{
	StringList	res;		// [str(index)] [shortname]
	
	for (const auto it : m_SourceFileLUT)
	{
		SourceFileClass	*sfc = it.second;
		assert(sfc);
		
		const wxString	map_name = sfc->GetDirMapName();
		assert(!map_name.empty());
		
		const int	map_index = GetMapIndexFromMapName(map_name);
		assert(map_index >= 0);
		
		const wxString	shortname_cased = sfc->GetShortCasedName();
		
		res.push_back(to_string(map_index));
		res.push_back(shortname_cased.ToStdString());
	}
	
	return res;
}

vector<DirMap>			m_DirMapList;
unordered_map<string, int>	m_MapNameToIndex;
unordered_map<string, int>	m_MapClientPathToIndex;
	
StringList		GetDirMapRelativeSFCNames(void) const;
	
	// DirMaps
	StringList		GetSerializedDirMaps(void) const;
	bool			HasClientMap(const wxString &client_fullpath) const;
	wxString		GetMapNameFromDir(const wxString &map_dir) const;
	bool			HasSymMap(const wxString &sym_name) const;
	string			MappedFileToClientShortName(const string &lua_fullpath) const;
	DirMap			NewMap(const wxString &client_fullpath, const wxString &name = wxEmptyString);
	DirMap			NewOrExistingMap(const wxString &client_fullpath, const wxString &name = wxEmptyString);
	bool			DeleteMap(const wxString &map_name);
	DirMap			GetMap(const int &index) const;
	vector<DirMap>		GetMapList(void) const;
	vector<SourceFileClass*>	GetDirMapSFCs(const string &map_name) const;
	StringList		GetDirMapFiles(const string &map_name) const;
	bool			RenameMapping(const wxString &map_name, const wxString &new_name);
	DirMap			GetMapFromMapName(const wxString &map_name) const;
	DirMap			GetMapFromClientDir(const wxString &client_dir) const;
	
//---- Lua Directory Mapping --------------------------------------------------

class DirMap
{
	friend class Controller;
public:	
	// ctors
	DirMap();
	DirMap(const wxString &client_dir, const wxString &lua_map_name);
	
	bool	IsOk(void) const;
	
	wxString	GetMapName(void) const;
	wxString	GetClientDir(void) const;
	int		GetIndex(void) const
	{
		return m_Index;
	}
	
private:

	wxString	m_SymName;		// SLASH-FREE
	wxString	m_ClientDir;		
	
	mutable int	m_Index;		// doesn't need to be stored?
};

//---- Get Dir from File or Dir -----------------------------------------------

// private
wxString	Controller::GetFileDir(const wxString &x_path) const
{
	if (wxFileName::DirExists(x_path))	return x_path;		// was path
	// must be file
	assert(wxFileName::FileExists(x_path));
	
	wxFileName	cfn(x_path);
	assert(cfn.IsOk());
	
	return cfn.GetPath();
}

//-----------------------------------------------------------------------------

	const bool	screencast_f = IsScreencastMode();
	// takes FOCUS away
	wxRichToolTip	tip("Network", msg);
	tip.SetTipKind(wxTipKind_Top);
	tip.SetIcon(f ? wxICON_INFORMATION : wxICON_WARNING);
	tip.SetTimeout(NOTIFICATION_MESSAGE_TIMEOUT_MS);
	
	if (f)
	{	tip.SetBackgroundColour(*wxWHITE, wxColour(0xe0, 0xe8, 0xf0));
	}
	else
	{	const wxColour	top = wxColourDatabase().Find("ORANGE").ChangeLightness(140);
		const wxColour	bottom = wxColourDatabase().Find("YELLOW").ChangeLightness(140);
		tip.SetBackgroundColour(top, bottom);
	}
	
	wxWindow	*focus_win = m_ToolBar;
	
	wxRect	combo_screen_rc = m_DaemonHostNPortComboBox->GetScreenRect();
	wxPoint	combo_screen_pt {combo_screen_rc.x + (combo_screen_rc.width / 2), combo_screen_rc.y + (combo_screen_rc.height / 2)};
	wxPoint	client_pt = focus_win->ScreenToClient(combo_screen_pt);
	wxRect	client_rc {client_pt, wxSize(1, 1)};
	
	tip.ShowFor(focus_win, &client_rc);
	
	// reset focus to this window
	// CallAfter(&TopFrame::SetFocus);

//---- Dump All ---------------------------------------------------------------

void	BottomNotePanel::DumpAll(void)
{
	wxPoint	pt = ::wxGetMousePosition();			// global coords
	wxWindow	*win = wxFindWindowAtPoint(pt);
	wxString	name = win ? win->GetLabel() : "n/a";
	
	m_TopFrame.SetStatusComment(wxString("picked win: ") + name);
	
	uMsg("BottomNotePanel::DumpAll(win = %S)", name);
	
	for (PaneBook *bnb : m_Books)
	{
		const wxRect	rc = bnb->GetScreenRect();
		wxString	s;
		
		s.Printf("book %d, %s, rc(%d, %d, %d, %d)", bnb->GetBookID(), bnb->IsShown() ? "shown" : "HIDDEN", rc.x, rc.y, rc.width, rc.height);
		uMsg("  %s", s);
		
		// bnb->Dump();
		uMsg("");
	}
}

static const
unordered_set<int>	s_StartedLuaLUT { PANE_ID_LOCALS, PANE_ID_GLOBALS, PANE_ID_WATCHES, PANE_ID_MEMORY, PANE_ID_STACK };

//---- Dump Keyboard Shortcuts ------------------------------------------------

void	TopFrame::DumpKeyboardShortcuts(wxCommandEvent &e)
{
	// wxAcceleratorTable	*accel_tab = GetAcceleratorTable();
	// assert(accel_tab);
	
	for (int i = 0; i < m_KeyboardShortcuts.size(); i++)
	{
		const wxAcceleratorEntry	&elm = m_KeyboardShortcuts[i];
		
		const int	cmd_id = elm.GetCommand();
		const wxString	text_accel = elm.ToString();
		const wxString	raw_accel = elm.ToRawString();
		
		uMsg(" acc[%d] cmd %d %S (raw %S)", i, cmd_id, text_accel, raw_accel);
	}
}

void	paint(Graphics &g) override
{
	const iRect	r = getLocalBounds();
	
	g.fillAll(Color(RGB_COLOR::GTK_GREY));
	
	// border
	g.setColour(Color(RGB_COLOR::GTK_GREY).Darker(80));
	g.drawRect(getLocalBounds().reduced(1), 1);
	
	{
		const iRect	list_r = m_ListCtrl.getBoundsInParent();
		
		Graphics::ScopedSaveState ss(g);
		
		g.setOrigin(list_r.x(), list_r.y());
		
		m_ListCtrl.paintEntireComponent(g, false/*ignore alpha?*/);
	}
	
	g.setColour(Color(RGB_COLOR::RED));
	
	g.drawLine(0, 0, r.right(), r.bottom(), 1.5/*thickness*/);
}

virtual void	RemoveAllHighlights(void) = 0;
virtual void	RemoveSearchHighlights(void) = 0;

virtual void	SetRedAnnotation(const int ln, const string &annotation_msg) = 0;
virtual void	ClearRedAnnotations(void) = 0;

virtual bool	HasLineMarker(const int ln, const MARGIN_MARKER_TYPE &hl_typ) = 0;
virtual void	SetLineMarker(const int ln, const MARGIN_MARKER_TYPE &hl_typ, const bool f = true) = 0;
virtual void	RemoveLineMarkers(const MARGIN_MARKER_TYPE &hl_typ) = 0;

bool	HasLineMarker(const int ln, const MARGIN_MARKER_TYPE &hl_typ) override
{
	return m_EditorCtrl.HasLineMarker(hl_typ, ln);
}

void	SetLineMarker(const int ln, const MARGIN_MARKER_TYPE &hl_typ, const bool f) override
{
	m_EditorCtrl.ToggleLineMarker(hl_typ, ln, f);
}

void	RemoveLineMarkers(const MARGIN_MARKER_TYPE &hl_typ) override
{
	m_EditorCtrl.RemoveLineMarkers(hl_typ);
}

void	SetRedAnnotation(const int ln, const string &annotation_msg) override
{
	m_EditorCtrl.SetAnnotation(ln, annotation_msg);
}

void	ClearRedAnnotations(void) override
{
	// remove any Lua error annotations
	m_EditorCtrl.ClearAnnotations();
}	

void	RemoveAllHighlights(void) override
{
	m_EditorCtrl.RemoveAllHighlights();
}

void	RemoveSearchHighlights(void) override
{
	m_EditorCtrl.RemoveSearchHighlights();
}

	if (!center_f)		return;
	
	// uMsg("ShowLine(%d) centered", ln);
	
	// v-CENTER line
	const int	vis_lines = LinesOnScreen();
	const int	vis_lines_d2 = vis_lines / 2;
	
	int	target_top_ln = (ln - 1) - vis_lines_d2;
	if (target_top_ln < 0)		target_top_ln = 0;
	
	SetFirstVisibleLine(target_top_ln);
	
	// const int	tot_src_Lines = GetLineCount();
	// int	first_vis_ln = GetFirstVisibleLine();
	// EnsureVisible(ln - 1);
	// ScrollRange(int secondary, int primary);
	
#if 0
//---- Notify Total Line Count Changed (hence update breakpoints) -------------

void	SourceFileClass::NotifyEditorLineCountChanged(void)
{
	#if 0
	
	// get updated breakpoint positions from editor
	vector<int>	bp_lines = m_EditorCtrl.GetUpdatedBreakpointLines();
	
	// replace this SFC's breakpoints
	m_Controller.SetSFCBreakpoints(this, bp_lines);
	
	// broadcast update
	m_Controller.OnBreakpointUpdated(GetShortName());
	
	#endif
}

//---- Restore Cursor Pos -----------------------------------------------------

void	SourceFileClass::RestoreCursorPos(void)
{
	// m_EditorCtrl.RestoreStcPos();
}

//---- Get (wxSTC) Line From Position -----------------------------------------

int	SourceFileClass::GetStcLineFromPos(const int pos) const
{
	// const int	ln = m_EditorCtrl.GetStcLineFromPos(pos);
	
	return 0;
}

//---- Show Span --------------------------------------------------------------

void	SourceFileClass::ShowSpan(const int pos1, const int pos2)
{
	// m_EditorCtrl.ShowSpan(pos1, pos2);
}

//---- Set Focus --------------------------------------------------------------

void	SourceFileClass::SetFocus(void)
{
	// m_EditorCtrl.SetFocus();
	// SetSTCFocus
}

//---- Get stcPos -------------------------------------------------------------

stcPos	SourceFileClass::GetStcPosition(void) const
{
	// return m_EditorCtrl.GetStcPosition();
	return stcPos()
}

//---- Has Valid Lua Functions ? ----------------------------------------------

bool	SourceFileClass::HasValidLuaFunctions(void) const
{
	// return m_EditorCtrl.HasValidFunctions();
}

//---- Get Sorted Function Bookmarks ------------------------------------------

vector<FunctionBookmark>	SourceFileClass::GetLuaFunctions(void) const
{
	vector<FunctionBookmark>	bookmarks;	// (m_EditorCtrl.GetLuaFunctions());
	
	return bookmarks;
}

//---- Get Updated Breakpoint Lines -------------------------------------------

vector<int>	EditorCtrl::GetUpdatedBreakpointLines(void)
{
	uMsg("EditorCtrl::GetUpdatedBreakpointLines()");
	
	const int	n_lines = GetNumberOfLines();
	const uint32_t	BREAKPOINT_MARKER_MASK = 1L << (int) MARKER_INDEX::BREAKPOINT;
	
	vector<int>	bp_lines;
	
	for (int ln = 0; ln < n_lines; ln++)
	{
		if (!(MarkerGet(ln) & BREAKPOINT_MARKER_MASK))	continue;
		
		bp_lines.push_back(ln + 1);
	}
	
	return bp_lines;
}

//---- Add Breakpoints --------------------------------------------------------

int	Controller::AddBreakpointsList_LL(const vector<wxString> &bp_str_list)
{
	const int	n_bf = m_BreakpointSet.size();
	
	m_BreakpointSet.insert(bp_str_list.begin(), bp_str_list.end());
	
	return m_BreakpointSet.size() - n_bf;	// some hashset entries might have been overwritten
}

enum : int
{	// mapped to imageList
	TreeCtrlIcon_File = 0,
	TreeCtrlIcon_FileSelected,
	TreeCtrlIcon_Folder,
	TreeCtrlIcon_FolderSelected,
	TreeCtrlIcon_FolderOpened
};

const size_t	n_cols = hdr.getNumColumns(true/*onlyCountVisible?*/);
		
		vector<COL_ID>	vis_cols;

		for (int i = 0; i < n_cols; i++)
		{
			const int	col = hdr.getColumnIdOfIndex(i, true/*onlyCountVisible?*/);
			assert(col < s_ColList.size());
			
			const COLUMN_T	col_id = s_ColList[col];
			vis_cols.push_back(col_id);
			
			m_MaxColWidthMap[col_id] = 1;
		}
		
	#if 0
	// const iRect	ctx_r(g.getClipBounds());			// may be viewport-clipped!
	
	// const int	tab_row_h = ctx_r.h();
	// const int	y0 = (tab_row_h - 1) - m_FixedH;
	
	Graphics::ScopedSaveState ss(g);
				
	g.setOrigin(r.x(), r.y());
			
	if (g.reduceClipRegion(0, 0, r.w(), r.h()))			// nonsense -- is the guilty party ???
	{
		DrawTextCachedChars(g, s, r.Local(), right_align_f);
	}
	#endif
	
bool	keyPressed(const KeyPress &e) override
{
	const int	vk = e.getKeyCode();
	
	uWarn("FunctionsComponent::keyPressed(vk = %d)", vk);
	
	m_Signals.OnJKey(CTX_JUCE, vk); 
	
	return true;
}
	